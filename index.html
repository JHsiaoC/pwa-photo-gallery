<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="robots" content="noindex, nofollow" />
  <title>My Photo Album</title>
  <meta name="theme-color" content="#0F172A" />
  <link rel="manifest" href="manifest.webmanifest">
  <link rel="icon" href="icons/icon-192.png">
  <style>
    :root {
      --bg:#050812;
      --card:#0f172a;
      --muted:#94a3b8;
      --text:#f1f5f9;
      --accent:#38bdf8;
      --accent-strong:#0ea5e9;
      --sidebar:#0b1220;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: radial-gradient(circle at top, rgba(56,189,248,.25), transparent 45%), var(--bg);
      color: var(--text);
      min-height: 100vh;
    }
    header {
      position: sticky;
      top: 0;
      z-index: 20;
      backdrop-filter: saturate(180%) blur(10px);
      background: rgba(5,8,18,.9);
      border-bottom: 1px solid rgba(148,163,184,.15);
    }
    .wrap { max-width: 1200px; margin: 0 auto; padding: 12px 16px; }
    .row { display: flex; gap: 12px; align-items: center; }
    h1 { font-size: 18px; margin: 0; letter-spacing: .2px; }
    .spacer { flex: 1; }
    button, label.btn {
      cursor: pointer;
      border: 1px solid rgba(148,163,184,.25);
      background: linear-gradient(180deg, #1e293b, #0f172a);
      color: var(--text);
      padding: 8px 12px;
      border-radius: 12px;
      font-weight: 600;
      transition: border-color .2s ease, transform .2s ease;
    }
    button:hover, label.btn:hover { border-color: rgba(148,163,184,.45); }
    button:active { transform: scale(.98); }
    input[type=file] { display: none; }

    .app-shell { display: flex; gap: 24px; max-width: 1200px; margin: 0 auto; padding: 0 16px 120px; }
    .sidebar { display: none; }
    .brand-card { display: flex; align-items: center; gap: 12px; }
    .brand-card .emoji {
      width: 48px;
      height: 48px;
      border-radius: 16px;
      background: rgba(56,189,248,.15);
      display: grid;
      place-items: center;
      font-size: 20px;
    }
    .brand-card strong { display:block; font-size: 16px; }
    .brand-card span { color: var(--muted); font-size: 12px; }
    .sidebar-section { display:flex; flex-direction:column; gap:10px; }
    .sidebar-section.hidden { display:none; }
    .section-header { display:flex; justify-content:space-between; align-items:center; font-size:12px; text-transform:uppercase; letter-spacing:.08em; color:var(--muted); }
    .section-header button { padding:6px 10px; border-radius:999px; }
    .folder-list,
    .album-list { display: flex; flex-direction: column; gap: 8px; max-height: calc(100vh - 260px); overflow-y: auto; }
    .album-item {
      display: flex;
      align-items: center;
      gap: 12px;
      width: 100%;
      background: rgba(15,23,42,.75);
      border-radius: 16px;
      padding: 10px 12px;
      border: 1px solid transparent;
      text-align: left;
    }
    .album-item .album-icon { font-size: 18px; }
    .album-meta { display: flex; flex-direction: column; font-size: 11px; color: var(--muted); }
    .album-meta strong { font-size: 14px; color: var(--text); }
    .album-item.active { border-color: var(--accent); background: rgba(56,189,248,.12); }

    .workspace {
      flex: 1;
      min-height: calc(100vh - 140px);
      padding: 32px 16px 140px;
    }
    .album-heading { display:none; }
    .eyebrow { margin:0; font-size:11px; text-transform:uppercase; letter-spacing:.2em; color:var(--muted); text-align:center; }
    #activeAlbumTitle { margin:4px 0 0; font-size: 28px; text-align:center; }
    .controls-stack { display:flex; flex-direction:column; gap:8px; align-items:flex-start; }
    .control-row { display:flex; flex-wrap:wrap; gap:12px; align-items:center; font-size:12px; color:var(--muted); }
    .control-row.hidden { display:none; }
    .sort-toolbar {
      display:flex;
      gap:12px;
      align-items:flex-end;
      flex-wrap:wrap;
      font-size:12px;
      color:var(--muted);
    }
    .sort-toolbar select {
      background: rgba(15,23,42,.85);
      color: var(--text);
      border: 1px solid rgba(148,163,184,.25);
      border-radius: 12px;
      padding: 6px 10px;
      font-weight:600;
    }
    .sort-toolbar button {
      padding:6px 10px;
      border-radius:12px;
    }
    .drive-shell { background: rgba(15,23,42,.75); border-radius: 28px; border:1px solid rgba(148,163,184,.12); box-shadow: 0 20px 60px rgba(0,0,0,.4); padding: 20px; min-height: 60vh; }
    .drive-header { display:grid; grid-template-columns:auto 1fr auto; align-items:center; gap:16px; margin-bottom:12px; }
    .drive-heading { text-align:center; }
    .drive-back-btn { width:40px; height:40px; border-radius:20px; border:1px solid rgba(148,163,184,.25); background: rgba(15,23,42,.9); color:var(--text); font-size:18px; cursor:pointer; display:grid; place-items:center; }
    .drive-back-btn.hidden { visibility:hidden; }
    .drive-actions { display:flex; gap:12px; justify-content:flex-end; align-items:center; }
    .action-btn { width:40px; height:40px; border-radius:20px; border:1px solid rgba(148,163,184,.25); background: rgba(15,23,42,.9); color:var(--text); font-size:20px; cursor:pointer; display:flex; align-items:center; justify-content:center; line-height:1; letter-spacing:1px; }
    .ellipsis-icon { font-size:16px; letter-spacing:2px; white-space:nowrap; display:inline-block; transform:translateY(-1px); }
    .circle-check {
      width:18px;
      height:18px;
      border-radius:50%;
      border:1.5px solid rgba(148,163,184,.7);
      display:inline-flex;
      align-items:center;
      justify-content:center;
      font-size:11px;
      margin-right:8px;
    }
    .dropdown { position:relative; }
    .dropdown-menu { position:absolute; top:48px; right:0; background:rgba(11,17,31,.95); border:1px solid rgba(148,163,184,.2); border-radius:16px; min-width:220px; padding:8px 0; box-shadow:0 12px 30px rgba(0,0,0,.5); z-index:20; display:none; }
    .dropdown-menu.show { display:block; }
    .dropdown-menu button { width:100%; background:none; border:none; color:var(--text); padding:10px 16px; text-align:left; font-size:14px; display:flex; align-items:center; gap:10px; cursor:pointer; }
    .dropdown-menu button:hover { background:rgba(56,189,248,.1); }
    .dropdown-divider { height:1px; background:rgba(148,163,184,.2); margin:6px 0; }
    .search-bar { margin:8px 0 18px; position:relative; }
    .search-bar input { width:100%; padding:12px 16px 12px 40px; border-radius:16px; border:1px solid rgba(148,163,184,.25); background:rgba(15,23,42,.85); color:var(--text); font-size:14px; }
    .search-bar span { position:absolute; top:50%; left:14px; transform:translateY(-50%); color:var(--muted); font-size:16px; }
    .drive-section { margin-top:20px; }
    .drive-section h3 { margin:0 0 12px; font-size:16px; color:var(--muted); text-transform:uppercase; letter-spacing:.2em; }
    .folder-grid { display:grid; grid-template-columns: repeat(auto-fill, minmax(180px,1fr)); gap:12px; }
    .folder-card { position:relative; background:rgba(15,23,42,.8); border:1px solid rgba(148,163,184,.2); padding:16px; border-radius:20px; min-height:140px; display:flex; flex-direction:column; justify-content:space-between; cursor:pointer; }
    .folder-card.active { border-color: var(--accent); }
    .folder-card .name { font-weight:600; font-size:16px; }
    .folder-card .count { font-size:12px; color:var(--muted); }
    .folder-card .select-indicator { position:absolute; top:10px; right:10px; width:20px; height:20px; border-radius:50%; border:2px solid rgba(148,163,184,.4); }
    .folder-card.selected .select-indicator { background:var(--accent); border-color:var(--accent); }
    .drive-contents { margin-top:24px; }
    .folder-list-view { display:flex; flex-direction:column; gap:10px; }
    .folder-list-view .folder-card { flex-direction:row; align-items:center; min-height:auto; padding:14px 20px; }
    .folder-list-view .folder-card .name { font-size:15px; }
    .media-card { justify-content:flex-start; }
    .media-card .thumb { width:100%; height:160px; border-radius:16px; background:#020617; overflow:hidden; display:flex; align-items:center; justify-content:center; margin-bottom:12px; }
    .media-card img,
    .media-card video { width:100%; height:100%; object-fit:cover; border-radius:inherit; }
    .media-card video { pointer-events:none; }
    .media-card .name { font-size:15px; margin-bottom:4px; }
    .media-card .meta { padding:0; width:100%; }
    .media-card .chip { margin-left:auto; }
    .media-card .thumb .text-card { height:100%; border-radius:inherit; padding:16px; line-height:1.4; color:var(--muted); }
    .folder-list-view .media-card { flex-direction:row; align-items:center; }
    .folder-list-view .media-card .thumb { width:140px; height:90px; margin:0 16px 0 0; }
    .folder-list-view .media-card .meta { flex-direction:column; align-items:flex-start; gap:4px; }
    .grid.list-view { display:flex; flex-direction:column; }
    .grid.list-view .card { display:flex; gap:16px; height:auto; }
    .grid.list-view .card img, .grid.list-view .card video { width:140px; height:90px; border-radius:16px; }
    .grid.list-view .text-card { width:140px; height:90px; }
    .grid.list-view .text-card { width:140px; height:90px; }
    .bottom-tabs { position:fixed; bottom:16px; left:50%; transform:translateX(-50%); background:rgba(11,17,31,.9); border:1px solid rgba(148,163,184,.2); border-radius:999px; padding:10px 18px; display:flex; gap:16px; z-index:30; box-shadow:0 10px 40px rgba(0,0,0,.5); align-items:center; }
    .bottom-tabs .tab-buttons,
    .bottom-tabs .selection-actions { display:flex; gap:12px; align-items:center; }
    .bottom-tabs .selection-actions.hidden { display:none; }
    .bottom-tabs button { background:none; border:none; color:var(--muted); font-weight:600; padding:6px 14px; border-radius:999px; cursor:pointer; transition:background .2s ease, color .2s ease; }
    .bottom-tabs button.active { background:rgba(56,189,248,.12); color:var(--text); }
    .bottom-tabs .selection-actions button { color:var(--text); border:1px solid rgba(148,163,184,.3); background:rgba(15,23,42,.8); }
    .bottom-tabs .selection-actions button:disabled { opacity:.4; cursor:not-allowed; }
    .bottom-tabs.action-mode .tab-buttons { display:none; }
    .bottom-tabs.action-mode .selection-actions { display:flex; }
    .drive-shell .select-indicator { opacity:0; transition:opacity .2s ease; }
    .drive-shell.selecting .select-indicator { opacity:1; }
    .album-shell { background: rgba(15,23,42,.75); border-radius: 28px; border:1px solid rgba(148,163,184,.12); box-shadow: 0 20px 60px rgba(0,0,0,.4); padding: 24px; min-height: 60vh; }
    .photos-header { text-align:center; margin-bottom:16px; }
    #photosHeading { margin:0; font-size:28px; }
    .album-toolbar { display:flex; align-items:center; justify-content:center; gap:12px; margin-bottom:16px; }
    .album-toolbar .photos-header { flex:1; margin-bottom:0; }
    .album-media-panel { margin-top:20px; }
    .album-grid { display:grid; grid-template-columns: repeat(3, minmax(0,1fr)); gap:18px; }
    @media (max-width: 1024px) {
      .album-grid { grid-template-columns: repeat(auto-fill, minmax(200px,1fr)); }
    }
    .album-card {
      aspect-ratio: 1;
      border-radius: 24px;
      border:1px solid rgba(148,163,184,.2);
      background: rgba(15,23,42,.85);
      color: var(--text);
      display:flex;
      flex-direction:column;
      justify-content:center;
      align-items:center;
      gap:12px;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      cursor:pointer;
      font-weight:600;
      text-align:center;
    }
    .album-card .count { font-size:12px; color:var(--muted); }
    .album-card.new { border:1px dashed rgba(148,163,184,.4); color:var(--muted); }
    .album-card.active { border-color: var(--accent); box-shadow:0 0 0 2px rgba(56,189,248,.4); }
    .album-empty { text-align:center; padding:24px; color:var(--muted); }

    .grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(180px,1fr)); gap: 12px; margin-top: 18px; }
    .card { position: relative; border-radius: 16px; overflow: hidden; background: var(--card); border: 1px solid rgba(148,163,184,.15); box-shadow: 0 6px 20px rgba(0,0,0,.25); }
    .card img, .card video { display: block; width: 100%; height: 200px; object-fit: cover; background: #111827; }
    .card video { pointer-events: none; }
    .media-flag {
      position:absolute;
      top:8px;
      right:8px;
      background:rgba(5,8,18,.75);
      border-radius:999px;
      padding:4px 8px;
      font-size:12px;
      display:flex;
      align-items:center;
      gap:4px;
    }
    .meta { display:flex; align-items:center; justify-content: space-between; gap:8px; padding: 8px 10px; font-size: 12px; color: var(--muted); }
    .chip { padding: 3px 8px; border-radius: 999px; background: rgba(56,189,248,.12); color: var(--text); border:1px solid rgba(56,189,248,.35); font-weight:600; }
    .text-card {
      width: 100%;
      height: 200px;
      border-radius: 16px;
      background: rgba(15,23,42,.85);
      color: var(--muted);
      padding: 16px;
      overflow: hidden;
      display:flex;
      align-items:flex-start;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 13px;
      white-space: pre-wrap;
    }
    .empty { text-align:center; color: var(--muted); padding: 60px 16px; border: 1px dashed rgba(148,163,184,.25); border-radius: 18px; margin-top: 24px; }
    .empty strong { color: var(--text); }


    .footer { text-align:center; color: var(--muted); padding: 24px; }
    .hidden { display:none !important; }

    .modal {
      position: fixed;
      inset: 0;
      background: rgba(5,8,18,.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 30;
    }
    .modal-card {
      background: var(--sidebar);
      border-radius: 20px;
      padding: 24px;
      width: min(360px, 90vw);
      border: 1px solid rgba(148,163,184,.2);
      box-shadow: 0 20px 60px rgba(0,0,0,.45);
    }
    .modal-card h3 { margin-top:0; margin-bottom:12px; }
    .modal-card label { display:block; font-size:13px; color:var(--muted); margin-bottom:4px; }
    .modal-card input {
      width: 100%;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(148,163,184,.3);
      background: rgba(15,23,42,.9);
      color: var(--text);
      font-size: 14px;
    }
    .modal-actions { display:flex; justify-content:flex-end; gap:8px; margin-top:18px; }

    @media (max-width: 960px) {
      .app-shell { flex-direction: column; }
      .sidebar { width: 100%; flex-direction: row; flex-wrap: wrap; }
      .folder-list,
      .album-list { flex-direction: row; flex-wrap: wrap; max-height: none; }
      .album-item { flex: 1 1 160px; }
    }

    .photo-viewer {
      position: fixed;
      inset: 0;
      background: rgba(3,6,15,.95);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 60;
      padding: 0;
      backdrop-filter: blur(6px);
    }
    .photo-viewer .viewer-frame {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      background: transparent;
      border: none;
      padding: 0;
    }
    .viewer-top {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      padding: 16px 16px 0;
      color: var(--text);
      text-shadow: 0 1px 3px rgba(0,0,0,.6);
    }
    .viewer-top-info {
      display: flex;
      flex-direction: column;
      gap: 4px;
      font-size: 13px;
    }
    .viewer-top-info strong {
      font-size: 16px;
    }
    .viewer-top-info span {
      color: var(--muted);
      font-size: 12px;
    }
    .viewer-media {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
      touch-action: none;
    }
    .viewer-media img,
    .viewer-media video {
      width: 100%;
      height: 100%;
      object-fit: contain;
      background: #000;
      transition: transform .2s ease;
    }
    .viewer-media img.zoomed,
    .viewer-media video.zoomed {
      cursor: grab;
    }
    .viewer-actions {
      display: flex;
      justify-content: center;
      gap: 24px;
      padding: 16px;
    }
    .icon-btn {
      background: transparent;
      border: none;
      color: var(--text);
      font-size: 22px;
      padding: 8px;
      border-radius: 50%;
      cursor: pointer;
      transition: opacity .2s ease;
    }
    .icon-btn:hover {
      opacity: .8;
    }
    .photo-viewer.hide-chrome .viewer-top,
    .photo-viewer.hide-chrome .viewer-actions {
      opacity: 0;
      pointer-events: none;
    }
    .photo-viewer.hide-chrome {
      cursor: none;
    }

    .settings-modal .modal-card {
      width: min(420px, 95vw);
    }
    .settings-help {
      font-size:12px;
      color:var(--muted);
      margin-top:8px;
    }
    .settings-preview {
      margin-top:10px;
      padding:10px;
      border-radius:12px;
      background:rgba(15,23,42,.8);
      border:1px solid rgba(148,163,184,.2);
      font-size:13px;
    }
  </style>
</head>
<body>

<input type="file" id="fileInput" accept="image/*,video/*" multiple>

<div class="app-shell">
  <main class="workspace">
    <div class="drive-shell">
      <div class="drive-header">
        <button id="driveBackBtn" class="drive-back-btn hidden" type="button" aria-label="Back to parent">&lt;</button>
        <div class="drive-heading">
          <h2 id="activeAlbumTitle">Drive</h2>
        </div>
        <div class="drive-actions">
          <div class="dropdown">
            <button class="action-btn" id="primaryAddBtn" aria-haspopup="true" aria-expanded="false" aria-label="Add menu">+</button>
            <div class="dropdown-menu" id="addMenu">
              <button data-add="import">üì• Import Media</button>
              <button data-add="folder">üóÇÔ∏è New Folder</button>
              <button data-add="text">üìù New Text File</button>
            </div>
          </div>
          <div class="dropdown">
            <button class="action-btn" id="moreActionsBtn" aria-haspopup="true" aria-expanded="false" aria-label="More actions"><span class="ellipsis-icon">¬∑¬∑¬∑</span></button>
            <div class="dropdown-menu" id="moreMenu">
              <button data-action="select"><span class="circle-check">‚úì</span>Select</button>
              <div class="dropdown-divider"></div>
              <button data-sort="name-asc">‚ÜïÔ∏è Name (A‚ÜíZ)</button>
              <button data-sort="name-desc">‚ÜïÔ∏è Name (Z‚ÜíA)</button>
              <button data-sort="size-desc">‚¨ÜÔ∏è Largest</button>
              <button data-sort="size-asc">‚¨áÔ∏è Smallest</button>
              <button data-sort="created-desc">üÜï Newest</button>
              <button data-sort="created-asc">üï∞ Oldest</button>
              <div class="dropdown-divider"></div>
              <button data-view="list">‚ò∞ List View</button>
              <button data-view="grid">‚¨ö Thumbnail View</button>
            </div>
          </div>
        </div>
      </div>

      <div class="search-bar">
        <span>üîç</span>
        <input id="driveSearch" type="search" placeholder="Search Drive">
      </div>

      <div class="drive-section drive-contents">
        <div id="driveItems" class="folder-grid" aria-live="polite"></div>
        <p id="emptyState" class="empty">
          No media in <strong id="emptyAlbumLabel">Drive</strong> yet.<br>
          Everything stays on this device (IndexedDB). Works offline.
        </p>
      </div>
    </div>

    <div class="album-shell hidden">
      <div class="album-toolbar">
        <button id="albumBackBtn" class="drive-back-btn hidden" type="button" aria-label="Back to albums">&lt;</button>
        <div class="photos-header">
          <p class="eyebrow">Library</p>
          <h2 id="photosHeading">Photos</h2>
        </div>
      </div>
      <div id="albumGrid" class="album-grid"></div>
      <p id="albumEmpty" class="empty album-empty hidden">No albums yet. Tap <strong>New Album</strong> to create one.</p>
      <div id="albumMediaPanel" class="album-media-panel hidden">
        <div id="albumMedia" class="grid" aria-live="polite"></div>
        <p id="albumMediaEmpty" class="empty">This album is empty.</p>
      </div>
    </div>
  </main>
</div>



<p class="footer">PWA ‚Ä¢ Offline ‚Ä¢ Installable ‚Ä¢ Client-side storage</p>

<div id="albumModal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="albumModalTitle">
  <div class="modal-card">
    <h3 id="albumModalTitle">Create a new album</h3>
    <form id="albumForm">
      <label for="albumName">Name</label>
      <input id="albumName" name="albumName" type="text" placeholder="e.g. Summer 2024" required maxlength="60" autocomplete="off">
      <div class="modal-actions">
        <button type="button" id="albumCancel">Cancel</button>
        <button type="submit">Create</button>
      </div>
    </form>
  </div>
</div>

<div id="settingsModal" class="modal hidden settings-modal" role="dialog" aria-modal="true" aria-labelledby="settingsTitle">
  <div class="modal-card">
    <h3 id="settingsTitle">Settings</h3>
    <form id="settingsForm">
      <label for="namingScheme">Naming scheme for new uploads</label>
      <input id="namingScheme" name="namingScheme" type="text" placeholder="{{original}}-{{timestamp}}" maxlength="100">
      <p class="settings-help">Available tokens: <code>{{original}}</code>, <code>{{date}}</code>, <code>{{time}}</code>, <code>{{timestamp}}</code>, <code>{{counter}}</code>. File extension is preserved.</p>
      <div class="settings-preview">
        Preview: <strong id="namingPreview">photo-2024-01-01</strong>
      </div>
      <div class="modal-actions">
        <button type="button" id="settingsCancel">Cancel</button>
        <button type="submit">Save</button>
      </div>
    </form>
  </div>
</div>

<div id="photoViewer" class="photo-viewer hidden" role="dialog" aria-modal="true" aria-labelledby="viewerTitle">
  <div class="viewer-frame">
    <div class="viewer-top">
      <div class="viewer-top-info">
        <strong id="viewerTitle"></strong>
        <span id="viewerDetails"></span>
      </div>
      <button id="viewerClose" type="button" class="icon-btn" title="Close">‚úï</button>
    </div>
    <div class="viewer-media" id="viewerMedia">
      <img id="viewerImage" alt="">
      <video id="viewerVideo" class="hidden" playsinline></video>
    </div>
    <div class="viewer-actions">
      <button id="actionMoveFolder" type="button" class="icon-btn" title="Move to folder">üìÇ</button>
      <button id="actionAddAlbum" type="button" class="icon-btn" title="Add to album">‚≠ê</button>
      <button id="actionSave" type="button" class="icon-btn" title="Save to device">‚¨áÔ∏è</button>
      <button id="actionInfo" type="button" class="icon-btn" title="Details">‚ÑπÔ∏è</button>
      <button id="muteToggle" type="button" class="icon-btn hidden" title="Mute/unmute">üîá</button>
    </div>
  </div>
</div>

<nav class="bottom-tabs" id="bottomTabs">
  <div class="tab-buttons">
    <button class="active" data-tab="folders">Drive</button>
    <button data-tab="albums">Photos</button>
    <button data-tab="more">More</button>
  </div>
  <div class="selection-actions hidden" id="selectionActions">
    <button type="button" data-bulk="move" disabled>üìÇ Move</button>
    <button type="button" data-bulk="copy" disabled>üìÑ Copy</button>
    <button type="button" data-bulk="delete" disabled>üóë Delete</button>
    <button type="button" data-bulk="album" disabled>‚≠ê Add to album</button>
  </div>
</nav>

<script>
const basePath = "/pwa-photo-gallery/";

if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register(basePath + 'sw.js').catch(console.error);
  });
}

let deferredPrompt;
const installBtn = document.getElementById('installBtn');
window.addEventListener('beforeinstallprompt', (e) => {
  e.preventDefault();
  deferredPrompt = e;
  installBtn.classList.remove('hidden');
});
installBtn?.addEventListener('click', async () => {
  if (!deferredPrompt) return;
  deferredPrompt.prompt();
  await deferredPrompt.userChoice;
  deferredPrompt = null;
  installBtn.classList.add('hidden');
});

function idbOpen(dbName, version) {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(dbName, version);
    req.onupgradeneeded = (event) => {
      const db = req.result;
      let photoStore;
      if (!db.objectStoreNames.contains(STORE)) {
        photoStore = db.createObjectStore(STORE, { keyPath: 'id', autoIncrement: true });
      } else {
        photoStore = req.transaction.objectStore(STORE);
      }
      if (!photoStore.indexNames.contains('created')) photoStore.createIndex('created', 'created');
      if (!photoStore.indexNames.contains('folderId')) photoStore.createIndex('folderId', 'folderId');
      if (!photoStore.indexNames.contains('albumId')) photoStore.createIndex('albumId', 'albumId');

      let folderStoreRef;
      if (!db.objectStoreNames.contains(FOLDER_STORE)) {
        folderStoreRef = db.createObjectStore(FOLDER_STORE, { keyPath: 'id', autoIncrement: true });
        folderStoreRef.createIndex('name', 'name', { unique: false });
      } else {
        folderStoreRef = req.transaction.objectStore(FOLDER_STORE);
      }
      if (event.oldVersion < 4 && folderStoreRef) {
        folderStoreRef.openCursor().onsuccess = (ev) => {
          const cursor = ev.target.result;
          if (cursor) {
            const value = cursor.value;
            if (!('parentId' in value)) {
              value.parentId = null;
              cursor.update(value);
            }
            cursor.continue();
          }
        };
      }
      if (event.oldVersion < 3) {
        if (!db.objectStoreNames.contains(COLLECTION_STORE)) {
          const albums = db.createObjectStore(COLLECTION_STORE, { keyPath: 'id', autoIncrement: true });
          albums.createIndex('name', 'name', { unique: false });
        }
        if (!db.objectStoreNames.contains(COLLECTION_ITEMS_STORE)) {
          const items = db.createObjectStore(COLLECTION_ITEMS_STORE, { keyPath: 'id' });
          items.createIndex('albumId', 'albumId', { unique: false });
          items.createIndex('photoId', 'photoId', { unique: false });
        }
      }
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}
function idbAdd(db, store, value) {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(store, 'readwrite');
    const req = tx.objectStore(store).add(value);
    tx.oncomplete = () => resolve(req.result);
    tx.onerror = () => reject(tx.error);
  });
}
function idbPut(db, store, value) {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(store, 'readwrite');
    tx.objectStore(store).put(value);
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
}
function idbAll(db, store) {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(store, 'readonly');
    const req = tx.objectStore(store).getAll();
    req.onsuccess = () => resolve(req.result || []);
    req.onerror = () => reject(req.error);
  });
}
function idbClear(db, store) {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(store, 'readwrite');
    tx.objectStore(store).clear();
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
}
function idbDelete(db, store, key) {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(store, 'readwrite');
    tx.objectStore(store).delete(key);
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
}

const DB_NAME = 'pwa-photo-album';
const DB_VERSION = 4;
const STORE = 'photos';
const FOLDER_STORE = 'albums';
const COLLECTION_STORE = 'collections';
const COLLECTION_ITEMS_STORE = 'collection_items';
const SPECIAL_ALL = 'all';
const SPECIAL_UNSORTED = 'unsorted';
const TAB_FOLDERS = 'folders';
const TAB_ALBUMS = 'albums';

let db;
let folders = [];
let albums = [];
let albumMembership = new Map();
let photoCache = [];
let currentFolder = SPECIAL_ALL;
let currentAlbumId = null;
let activeTab = TAB_FOLDERS;
let modalContext = 'folder';

const folderListEl = document.getElementById('folderList');
const albumTitleEl = document.getElementById('activeAlbumTitle');
const photosHeadingEl = document.getElementById('photosHeading');
const emptyAlbumLabel = document.getElementById('emptyAlbumLabel');
const bottomTabsEl = document.getElementById('bottomTabs');
const selectionActionsEl = document.getElementById('selectionActions');
const tabButtons = document.querySelectorAll('.tab-buttons button[data-tab]');
const selectionActionButtons = selectionActionsEl ? Array.from(selectionActionsEl.querySelectorAll('button[data-bulk]')) : [];
const modal = document.getElementById('albumModal');
const albumModalTitle = document.getElementById('albumModalTitle');
const albumForm = document.getElementById('albumForm');
const albumInput = document.getElementById('albumName');
const albumCancel = document.getElementById('albumCancel');
const settingsBtn = document.getElementById('settingsBtn');
const settingsModal = document.getElementById('settingsModal');
const settingsForm = document.getElementById('settingsForm');
const settingsCancel = document.getElementById('settingsCancel');
const namingInput = document.getElementById('namingScheme');
const namingPreview = document.getElementById('namingPreview');
const photoViewer = document.getElementById('photoViewer');
const viewerClose = document.getElementById('viewerClose');
const viewerImg = document.getElementById('viewerImage');
const viewerVideo = document.getElementById('viewerVideo');
const viewerTitle = document.getElementById('viewerTitle');
const viewerDetails = document.getElementById('viewerDetails');
const viewerMediaEl = document.getElementById('viewerMedia');
const actionMoveFolder = document.getElementById('actionMoveFolder');
const actionAddAlbumBtn = document.getElementById('actionAddAlbum');
const actionSave = document.getElementById('actionSave');
const actionInfo = document.getElementById('actionInfo');
const muteToggle = document.getElementById('muteToggle');
const input = document.getElementById('fileInput');
const clearBtn = document.getElementById('clearBtn');
const exportBtn = document.getElementById('exportBtn');
const driveItemsEl = document.getElementById('driveItems');
const driveSearchInput = document.getElementById('driveSearch');
const primaryAddBtn = document.getElementById('primaryAddBtn');
const moreActionsBtn = document.getElementById('moreActionsBtn');
const addMenu = document.getElementById('addMenu');
const moreMenu = document.getElementById('moreMenu');
const driveShellEl = document.querySelector('.drive-shell');
const driveBackBtn = document.getElementById('driveBackBtn');
const albumShellEl = document.querySelector('.album-shell');
const albumGridEl = document.getElementById('albumGrid');
const albumEmptyEl = document.getElementById('albumEmpty');
const albumMediaPanel = document.getElementById('albumMediaPanel');
const albumMediaEl = document.getElementById('albumMedia');
const albumMediaEmptyEl = document.getElementById('albumMediaEmpty');
const albumBackBtn = document.getElementById('albumBackBtn');

let viewerUrl;
let currentViewList = [];
let currentViewerIndex = -1;
let mediaSortMode = 'created-desc';
let driveViewMode = 'grid';
let selectionMode = false;
let selectedFolders = new Set();
let selectedMedia = new Set();
let driveSearchTerm = '';
const SETTINGS_KEY = 'pwa-photo-gallery-settings';
const defaultSettings = { namingScheme: '{{original}}', counter: 1 };
let settings = loadSettings();
let chromeHidden = false;
let isZoomed = false;
let panX = 0;
let panY = 0;
let lastTapTime = 0;
let tapTimeout;
const gesture = { active: false, pointerId: null, startX: 0, startY: 0, initialX: 0, initialY: 0, panMode: false, startTime: 0 };

(async () => {
  db = await idbOpen(DB_NAME, DB_VERSION);
  await ensureFolderSeed();
  await loadFolders();
  await loadCollections();
  await refreshGallery();
  setActiveTab(TAB_FOLDERS);
})();

async function ensureFolderSeed() {
  // no-op: user decides when to create their first folder
}

async function loadFolders() {
  folders = await idbAll(db, FOLDER_STORE);
  folders.forEach(folder => {
    if (folder.parentId === undefined) folder.parentId = null;
  });
  folders.sort((a, b) => a.name.localeCompare(b.name));
  renderFolderList();
  if (typeof currentFolder === 'number' && !folders.find(f => f.id === currentFolder)) {
    currentFolder = SPECIAL_ALL;
  }
  selectedFolders.clear();
  selectedMedia.clear();
  renderGallery();
  updateHeader();
}

function renderFolderList() {
  if (!folderListEl) return;
  folderListEl.innerHTML = '';
  const counts = photoCache.reduce((acc, photo) => {
    const key = photo.folderId ?? SPECIAL_UNSORTED;
    acc[key] = (acc[key] || 0) + 1;
    return acc;
  }, {});
  const entries = [
    { id: SPECIAL_ALL, name: 'All Media', icon: 'üóÇÔ∏è', count: photoCache.length },
    { id: SPECIAL_UNSORTED, name: 'Main Library', icon: 'üì•', count: counts[SPECIAL_UNSORTED] || 0 }
  ];
  for (const folder of folders) {
    entries.push({ id: folder.id, name: folder.name, icon: 'üìÅ', count: counts[folder.id] || 0 });
  }
  for (const entry of entries) {
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'album-item' + (currentFolder === entry.id ? ' active' : '');
    btn.dataset.folder = String(entry.id);
    const icon = document.createElement('span');
    icon.className = 'album-icon';
    icon.textContent = entry.icon;
    const meta = document.createElement('div');
    meta.className = 'album-meta';
    const title = document.createElement('strong');
    title.textContent = entry.name;
    const count = document.createElement('span');
    const n = entry.count || 0;
    count.textContent = n ? `${n} item${n === 1 ? '' : 's'}` : 'Empty';
    meta.append(title, count);
    btn.append(icon, meta);
    folderListEl.appendChild(btn);
  }
}

folderListEl?.addEventListener('click', (event) => {
  const target = event.target.closest('button[data-folder]');
  if (!target) return;
  const value = target.dataset.folder;
  if (value === SPECIAL_ALL || value === SPECIAL_UNSORTED) {
    setActiveFolder(value);
  } else {
    setActiveFolder(Number(value));
  }
});

function createFolderCard(folder, count = 0) {
  const card = document.createElement('button');
  card.type = 'button';
  const isSelected = selectedFolders.has(folder.id);
  const isActive = folder.id === currentFolder;
  card.className = 'folder-card' + (isActive ? ' active' : '') + (isSelected ? ' selected' : '');
  const indicator = document.createElement('span');
  indicator.className = 'select-indicator';
  card.appendChild(indicator);
  const name = document.createElement('div');
  name.className = 'name';
  name.textContent = folder.name;
  const meta = document.createElement('div');
  meta.className = 'count';
  meta.textContent = count ? `${count} item${count === 1 ? '' : 's'}` : 'Empty';
  card.append(name, meta);
  card.addEventListener('click', () => {
    if (selectionMode) {
      if (selectedFolders.has(folder.id)) {
        selectedFolders.delete(folder.id);
        card.classList.remove('selected');
      } else {
        selectedFolders.add(folder.id);
        card.classList.add('selected');
      }
      updateSelectionChrome();
      return;
    }
    setActiveFolder(folder.id);
  });
  return card;
}

function createMediaTile(item, idx) {
  const card = document.createElement('button');
  card.type = 'button';
  const isSelected = selectedMedia.has(item.id);
  card.className = 'folder-card media-card' + (isSelected ? ' selected' : '');
  const indicator = document.createElement('span');
  indicator.className = 'select-indicator';
  card.appendChild(indicator);
  const thumb = document.createElement('div');
  thumb.className = 'thumb';
  const isVideo = item.kind === 'video' || item.type?.startsWith('video/');
  const isText = item.kind === 'text' || item.type === 'text/plain';
  let url = null;
  if (isVideo) {
    const video = document.createElement('video');
    video.muted = true;
    video.loop = true;
    video.autoplay = true;
    video.playsInline = true;
    url = URL.createObjectURL(item.blob);
    video.src = url;
    video.onloadeddata = () => { URL.revokeObjectURL(url); };
    video.onerror = () => { URL.revokeObjectURL(url); };
    thumb.appendChild(video);
  } else if (isText) {
    const textPreview = document.createElement('div');
    textPreview.className = 'text-card';
    textPreview.textContent = item.preview || item.name || 'Text file';
    thumb.appendChild(textPreview);
  } else {
    const img = document.createElement('img');
    img.loading = 'lazy';
    img.alt = item.name || 'Media file';
    url = URL.createObjectURL(item.blob);
    img.src = url;
    img.onload = () => { URL.revokeObjectURL(url); };
    img.onerror = () => { URL.revokeObjectURL(url); };
    thumb.appendChild(img);
  }
  card.appendChild(thumb);
  const name = document.createElement('div');
  name.className = 'name';
  name.textContent = item.name || 'Untitled';
  card.appendChild(name);
  const meta = document.createElement('div');
  meta.className = 'meta';
  const stamp = document.createElement('span');
  stamp.textContent = new Date(item.created).toLocaleDateString();
  const chip = document.createElement('span');
  chip.className = 'chip';
  chip.textContent = isVideo ? formatDuration(item.duration) : (isText ? 'Text file' : `${item.width}√ó${item.height}`);
  meta.append(stamp, chip);
  card.appendChild(meta);
  card.addEventListener('click', () => {
    if (selectionMode) {
      if (selectedMedia.has(item.id)) {
        selectedMedia.delete(item.id);
        card.classList.remove('selected');
      } else {
        selectedMedia.add(item.id);
        card.classList.add('selected');
      }
      updateSelectionChrome();
      return;
    }
    openViewerAt(idx);
  });
  return card;
}

function renderAlbumGrid() {
  if (!albumGridEl) return;
  const showingAlbums = !currentAlbumId;
  albumGridEl.classList.toggle('hidden', !showingAlbums);
  if (!showingAlbums) {
    albumEmptyEl?.classList.add('hidden');
    return;
  }
  albumGridEl.innerHTML = '';
  const emptyMsg = albumEmptyEl;
  const fragment = document.createDocumentFragment();

  const newCard = document.createElement('button');
  newCard.type = 'button';
  newCard.className = 'album-card new';
  newCard.innerHTML = '<div style="font-size:32px;">Ôºã</div><div class="title">New Album</div>';
  newCard.addEventListener('click', () => openCreateModal('album'));
  fragment.appendChild(newCard);

  if (!albums.length) {
    albumGridEl.appendChild(fragment);
    emptyMsg?.classList.remove('hidden');
    return;
  }
  emptyMsg?.classList.add('hidden');

  albums.forEach((album) => {
    const count = albumMembership.get(album.id)?.size || 0;
    const label = count === 1 ? '1 item' : `${count} items`;
    const card = document.createElement('button');
    card.type = 'button';
    card.className = 'album-card';
    card.innerHTML = '<div class=\"title\">' + album.name + '</div>' +
      '<div class=\"count\">' + label + '</div>';
    card.addEventListener('click', () => setActiveAlbum(album.id));
    fragment.appendChild(card);
  });

  albumGridEl.appendChild(fragment);
}

function setActiveFolder(value) {
  let target = value;
  if (value === SPECIAL_ALL || value === String(SPECIAL_ALL)) {
    target = SPECIAL_ALL;
  } else if (value === SPECIAL_UNSORTED || value == null) {
    target = SPECIAL_ALL;
  } else if (typeof value === 'string') {
    target = Number(value);
  }
  currentFolder = target;
  if (driveSearchInput) driveSearchInput.value = '';
  driveSearchTerm = '';
  selectedFolders.clear();
  selectedMedia.clear();
  updateSelectionChrome();
  const wasTab = activeTab;
  setActiveTab(TAB_FOLDERS);
  if (wasTab !== TAB_FOLDERS) return;
  if (!photoViewer.classList.contains('hidden')) closeViewer();
  renderFolderList();
  updateHeader();
  renderGallery();
}

function folderTitleFor(id) {
  if (id === SPECIAL_ALL) return 'Drive';
  if (id === SPECIAL_UNSORTED) return 'Main Library';
  const found = getFolderById(id);
  return found?.name || 'Folder';
}

function getFolderById(id) {
  if (typeof id !== 'number') return null;
  return folders.find(f => f.id === Number(id)) || null;
}

function getFolderParentId(id) {
  const folder = getFolderById(id);
  return folder?.parentId ?? null;
}

async function loadCollections() {
  albums = await idbAll(db, COLLECTION_STORE);
  albums.sort((a, b) => a.name.localeCompare(b.name));
  const items = await idbAll(db, COLLECTION_ITEMS_STORE);
  albumMembership = new Map();
  for (const entry of items) {
    if (!albumMembership.has(entry.albumId)) albumMembership.set(entry.albumId, new Set());
    albumMembership.get(entry.albumId).add(entry.photoId);
  }
  if (currentAlbumId && !albums.find(a => a.id === currentAlbumId)) {
    currentAlbumId = null;
  }
  renderAlbumGrid();
  renderGallery();
  updateHeader();
}

function setActiveAlbum(id) {
  currentAlbumId = id || null;
  setActiveTab(TAB_ALBUMS);
  if (!photoViewer.classList.contains('hidden')) closeViewer();
  renderAlbumGrid();
  updateHeader();
  renderGallery();
}

function albumTitleFor(id) {
  const found = albums.find(a => a.id === Number(id));
  return found?.name || 'Album';
}

function setActiveTab(tab) {
  activeTab = tab;
  tabButtons.forEach(btn => btn.classList.toggle('active', btn.dataset.tab === tab));
  driveShellEl?.classList.toggle('hidden', tab !== TAB_FOLDERS);
  albumShellEl?.classList.toggle('hidden', tab !== TAB_ALBUMS);
  if (tab !== TAB_FOLDERS && selectionMode) {
    toggleSelectionMode(false);
  }
  updateHeader();
  renderFolderList();
  renderAlbumGrid();
  renderGallery();
}

tabButtons.forEach(btn => btn.addEventListener('click', () => {
  const tab = btn.dataset.tab;
  switch (tab) {
    case TAB_FOLDERS:
      setActiveTab(TAB_FOLDERS);
      break;
    case TAB_ALBUMS:
      setActiveTab(TAB_ALBUMS);
      break;
    default:
      alert('This tab is coming soon.');
      break;
  }
}));

function updateHeader() {
  if (activeTab === TAB_FOLDERS) {
    const title = folderTitleFor(currentFolder);
    albumTitleEl.textContent = title;
    emptyAlbumLabel.textContent = title;
    if (photosHeadingEl) photosHeadingEl.textContent = 'Photos';
  } else {
    if (currentAlbumId) {
      const title = albumTitleFor(currentAlbumId);
      albumTitleEl.textContent = title;
      emptyAlbumLabel.textContent = title;
      if (photosHeadingEl) photosHeadingEl.textContent = title;
    } else {
      albumTitleEl.textContent = 'Photos';
      emptyAlbumLabel.textContent = 'Photos';
      if (photosHeadingEl) photosHeadingEl.textContent = 'Photos';
    }
  }
  updateBackButton();
}

function collectDescendantFolderIds(rootId) {
  const result = [];
  const stack = [rootId];
  while (stack.length) {
    const id = stack.pop();
    result.push(id);
    const children = folders.filter(folder => folder.parentId === id);
    children.forEach(child => stack.push(child.id));
  }
  return result;
}

async function deleteFoldersByIds(ids) {
  const folderSet = new Set();
  ids.forEach(id => {
    const chain = collectDescendantFolderIds(id);
    chain.forEach(value => folderSet.add(value));
  });
  if (!folderSet.size) return;
  const mediaToDelete = photoCache.filter(item => typeof item.folderId === 'number' && folderSet.has(item.folderId));
  for (const media of mediaToDelete) {
    await idbDelete(db, STORE, media.id);
  }
  for (const id of folderSet) {
    await idbDelete(db, FOLDER_STORE, id);
  }
}

function pickFolderDestination() {
  if (!folders.length) {
    return confirm('No folders available. Move to Drive (root)?') ? null : undefined;
  }
  const listing = folders.map((folder, idx) => `${idx + 1}. ${folder.name}`).join('\n');
  const promptText = `Move to folder:\n0. Drive (root)\n${listing}`;
  const input = prompt(promptText, '0');
  if (input === null) return undefined;
  const trimmed = input.trim();
  if (!trimmed || trimmed === '0') return null;
  const asNumber = Number(trimmed);
  if (!Number.isNaN(asNumber) && asNumber >= 1 && asNumber <= folders.length) {
    return folders[asNumber - 1].id;
  }
  const match = folders.find(folder => folder.name.toLowerCase() === trimmed.toLowerCase());
  if (match) return match.id;
  alert('Folder not found.');
  return undefined;
}

function pickAlbumDestination() {
  if (!albums.length) {
    alert('Create an album first.');
    return undefined;
  }
  const listing = albums.map((album, idx) => `${idx + 1}. ${album.name}`).join('\n');
  const input = prompt(`Add to album:\n${listing}`, '1');
  if (input === null) return undefined;
  const trimmed = input.trim();
  if (!trimmed) return undefined;
  const asNumber = Number(trimmed);
  if (!Number.isNaN(asNumber) && asNumber >= 1 && asNumber <= albums.length) {
    return albums[asNumber - 1].id;
  }
  const match = albums.find(album => album.name.toLowerCase() === trimmed.toLowerCase());
  if (match) return match.id;
  alert('Album not found.');
  return undefined;
}

function getSelectedMediaItems() {
  const list = [];
  selectedMedia.forEach((id) => {
    const found = photoCache.find(item => item.id === id);
    if (found) list.push(found);
  });
  return list;
}

function buildCopyName(name = 'media') {
  const dot = name.lastIndexOf('.');
  const base = dot > -1 ? name.slice(0, dot) : name;
  const ext = dot > -1 ? name.slice(dot) : '';
  const suffix = `${Date.now()}-${Math.floor(Math.random() * 1000)}`;
  return `${base || 'media'}-copy-${suffix}${ext}`;
}

function updateSelectionChrome() {
  if (selectionActionsEl) {
    selectionActionsEl.classList.toggle('hidden', !selectionMode);
  }
  if (bottomTabsEl) {
    bottomTabsEl.classList.toggle('action-mode', selectionMode);
  }
  const hasSelection = selectedMedia.size > 0 || selectedFolders.size > 0;
  selectionActionButtons.forEach(btn => { btn.disabled = !hasSelection; });
}

async function handleBulkAction(action) {
  switch (action) {
    case 'move':
      await bulkMoveSelected();
      break;
    case 'copy':
      await bulkCopySelected();
      break;
    case 'delete':
      await bulkDeleteSelected();
      break;
    case 'album':
      await bulkAddToAlbumSelected();
      break;
    default:
      break;
  }
}

async function bulkMoveSelected() {
  const items = getSelectedMediaItems();
  if (!items.length) return alert('Select media first.');
  const targetFolder = pickFolderDestination();
  if (targetFolder === undefined) return;
  await Promise.all(items.map(item => idbPut(db, STORE, { ...item, folderId: targetFolder })));
  selectedMedia.clear();
  await refreshGallery();
  toggleSelectionMode(false);
}

async function bulkCopySelected() {
  const items = getSelectedMediaItems();
  if (!items.length) return alert('Select media first.');
  const targetFolder = pickFolderDestination();
  if (targetFolder === undefined) return;
  for (const item of items) {
    const clone = {
      blob: item.blob,
      name: buildCopyName(item.name),
      type: item.type,
      created: Date.now(),
      captured: item.captured,
      width: item.width,
      height: item.height,
      duration: item.duration,
      kind: item.kind,
      size: item.size,
      preview: item.preview,
      folderId: targetFolder
    };
    await idbAdd(db, STORE, clone);
  }
  selectedMedia.clear();
  await refreshGallery();
  toggleSelectionMode(false);
}

async function bulkDeleteSelected() {
  const items = getSelectedMediaItems();
  const folderIds = Array.from(selectedFolders);
  if (!items.length && !folderIds.length) return alert('Select media or folders first.');
  const total = items.length + folderIds.length;
  if (!confirm(`Delete ${total} selected item(s)? This cannot be undone.`)) return;
  for (const item of items) {
    await idbDelete(db, STORE, item.id);
  }
  if (folderIds.length) {
    await deleteFoldersByIds(folderIds);
  }
  selectedMedia.clear();
  selectedFolders.clear();
  await loadFolders();
  await refreshGallery();
  toggleSelectionMode(false);
}

async function bulkAddToAlbumSelected() {
  const items = getSelectedMediaItems();
  if (!items.length) return alert('Select media first.');
  let albumId = currentAlbumId;
  if (!albumId) {
    albumId = pickAlbumDestination();
  }
  if (albumId === undefined) return;
  const membership = albumMembership.get(albumId) || new Set();
  for (const item of items) {
    if (membership.has(item.id)) continue;
    const entry = { id: `${albumId}-${item.id}`, albumId, photoId: item.id, created: Date.now() };
    try {
      await idbAdd(db, COLLECTION_ITEMS_STORE, entry);
      if (!albumMembership.has(albumId)) albumMembership.set(albumId, new Set());
      albumMembership.get(albumId).add(item.id);
    } catch {
      // ignore duplicates
    }
  }
  selectedMedia.clear();
  await loadCollections();
  toggleSelectionMode(false);
  alert('Added to album.');
}

function updateBackButton() {
  if (!driveBackBtn) return;
  const showBack = activeTab === TAB_FOLDERS && typeof currentFolder === 'number';
  driveBackBtn.classList.toggle('hidden', !showBack);
}

function loadSettings() {
  try {
    const raw = JSON.parse(localStorage.getItem(SETTINGS_KEY) || '{}');
    return { ...defaultSettings, ...raw };
  } catch {
    return { ...defaultSettings };
  }
}

function saveSettings() {
  try {
    localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
  } catch (err) {
    console.warn('Unable to persist settings', err);
  }
}

function updateNamingPreview() {
  if (!namingPreview) return;
  const fakeFile = { name: 'IMG_1234.jpg', type: 'image/jpeg', lastModified: Date.now() };
  const template = namingInput?.value || settings.namingScheme;
  namingPreview.textContent = generateFileName(fakeFile, true, template);
}

namingInput?.addEventListener('input', updateNamingPreview);

albumCancel?.addEventListener('click', closeModal);
modal?.addEventListener('click', (e) => {
  if (e.target === modal) closeModal();
});

albumForm?.addEventListener('submit', async (e) => {
  e.preventDefault();
  const name = albumInput.value.trim();
  if (!name) return;
  if (modalContext === 'folder') {
    const id = await idbAdd(db, FOLDER_STORE, { name, created: Date.now(), parentId: typeof currentFolder === 'number' ? currentFolder : null });
    closeModal();
    await loadFolders();
  } else {
    const id = await idbAdd(db, COLLECTION_STORE, { name, created: Date.now() });
    closeModal();
    await loadCollections();
    setActiveAlbum(Number(id));
  }
});

function openCreateModal(type) {
  modalContext = type;
  albumModalTitle.textContent = type === 'folder' ? 'Create a new folder' : 'Create a new album';
  albumInput.placeholder = type === 'folder' ? 'e.g. Family' : 'e.g. Favorites';
  modal.classList.remove('hidden');
  albumInput.value = '';
  setTimeout(() => albumInput.focus(), 10);
}

function closeModal() {
  modal.classList.add('hidden');
}

settingsBtn?.addEventListener('click', () => {
  namingInput.value = settings.namingScheme || defaultSettings.namingScheme;
  updateNamingPreview();
  settingsModal.classList.remove('hidden');
  setTimeout(() => namingInput.focus(), 10);
});

settingsCancel?.addEventListener('click', closeSettings);
settingsModal?.addEventListener('click', (e) => {
  if (e.target === settingsModal) closeSettings();
});
settingsForm?.addEventListener('submit', (e) => {
  e.preventDefault();
  settings.namingScheme = namingInput.value.trim() || defaultSettings.namingScheme;
  saveSettings();
  updateNamingPreview();
  closeSettings();
});

function closeSettings() {
  settingsModal.classList.add('hidden');
}

updateNamingPreview();
updateSelectionChrome();

if (driveSearchInput) {
  driveSearchInput.addEventListener('input', (e) => {
    driveSearchTerm = (e.target.value || '').toLowerCase();
    renderGallery();
  });
}

primaryAddBtn?.addEventListener('click', (e) => {
  e.stopPropagation();
  toggleMenu(addMenu, primaryAddBtn);
});

moreActionsBtn?.addEventListener('click', (e) => {
  e.stopPropagation();
  toggleMenu(moreMenu, moreActionsBtn);
});

addMenu?.addEventListener('click', (e) => {
  const button = e.target.closest('button[data-add]');
  if (!button) return;
  handleAddAction(button.dataset.add);
  closeMenus();
});

moreMenu?.addEventListener('click', (e) => {
  const targetBtn = e.target.closest('button');
  if (!targetBtn) return;
  if (targetBtn.dataset.sort) {
    handleSortSelection(targetBtn.dataset.sort);
    closeMenus();
    return;
  }
  if (targetBtn.dataset.view) {
    handleViewChange(targetBtn.dataset.view);
    closeMenus();
    return;
  }
  if (targetBtn.dataset.action === 'select') {
    toggleSelectionMode();
    closeMenus();
    return;
  }
});

selectionActionsEl?.addEventListener('click', async (e) => {
  const btn = e.target.closest('button[data-bulk]');
  if (!btn || btn.disabled) return;
  await handleBulkAction(btn.dataset.bulk);
});

document.addEventListener('click', (e) => {
  if (!e.target.closest('.dropdown')) closeMenus();
});

driveBackBtn?.addEventListener('click', () => {
  if (selectionMode) toggleSelectionMode(false);
  if (currentFolder === SPECIAL_ALL) return;
  const parentId = getFolderParentId(currentFolder);
  if (parentId == null) {
    setActiveFolder(SPECIAL_ALL);
  } else {
    setActiveFolder(parentId);
  }
});

albumBackBtn?.addEventListener('click', () => {
  if (selectionMode) toggleSelectionMode(false);
  setActiveAlbum(null);
});

const DB_READY = (async () => {
  while (!db) await new Promise(r => setTimeout(r, 50));
})();

input.addEventListener('change', async (e) => {
  await addFiles(e.target.files);
  input.value = '';
});

async function addFiles(fileList) {
  if (!fileList || !fileList.length) return;
  await DB_READY;
  const targetFolder = typeof currentFolder === 'number' ? currentFolder : null;
  const arr = Array.from(fileList).filter(isSupportedFile);
  if (!arr.length) return;
  for (const file of arr) {
    const arrayBuf = await file.arrayBuffer();
    const blob = new Blob([arrayBuf], { type: file.type || 'image/jpeg' });
    const created = Date.now();
    const captured = file.lastModified ? Number(file.lastModified) : created;
    const meta = await getMediaMeta(blob, blob.type || file.type || 'image/jpeg');
    const safeName = generateFileName(file);
    await idbAdd(db, STORE, {
      blob,
      name: safeName,
      type: blob.type || file.type || 'image/jpeg',
      created,
      captured,
      width: meta.width || 0,
      height: meta.height || 0,
      duration: meta.duration || 0,
      kind: meta.kind || 'image',
      size: blob.size || arrayBuf.byteLength || 0,
      folderId: targetFolder
    });
  }
  await refreshGallery();
}

async function addInlineMedia({ name, blob, type }) {
  await DB_READY;
  const created = Date.now();
  const pseudoFile = { name, type, lastModified: created };
  const safeName = generateFileName(pseudoFile);
  const textPreview = type === 'text/plain' ? (await blob.text()).slice(0, 200) : '';
  await idbAdd(db, STORE, {
    blob,
    name: safeName,
    type,
    created,
    captured: created,
    width: 0,
    height: 0,
    duration: 0,
    kind: type.startsWith('video/') ? 'video' : type.startsWith('image/') ? 'image' : 'text',
    size: blob.size || 0,
    preview: textPreview,
    folderId: typeof currentFolder === 'number' ? currentFolder : null
  });
  await refreshGallery();
}

function isSupportedFile(file) {
  const type = file.type || '';
  if (type.startsWith('image/') || type.startsWith('video/')) return true;
  const name = file.name?.toLowerCase() || '';
  return /(png|jpg|jpeg|gif|webp|mp4|mov|webm)$/i.test(name);
}

function imgSize(url) {
  return new Promise((res, rej) => { const i = new Image(); i.onload = ()=>res({width:i.naturalWidth, height:i.naturalHeight}); i.onerror=rej; i.src=url; });
}

function videoMeta(url) {
  return new Promise((resolve, reject) => {
    const video = document.createElement('video');
    video.preload = 'metadata';
    video.muted = true;
    video.onloadedmetadata = () => {
      resolve({
        width: video.videoWidth || 0,
        height: video.videoHeight || 0,
        duration: video.duration || 0
      });
      video.remove();
    };
    video.onerror = (err) => { video.remove(); reject(err || new Error('Video metadata error')); };
    video.src = url;
  });
}

async function getMediaMeta(blob, type) {
  const url = URL.createObjectURL(blob);
  try {
    const mime = type || 'image/jpeg';
    if (mime.startsWith('video/')) {
      try {
        const meta = await videoMeta(url);
        return { ...meta, kind: 'video' };
      } catch {
        return { width: 0, height: 0, duration: 0, kind: 'video' };
      }
    }
    const meta = await imgSize(url);
    return { width: meta.width, height: meta.height, duration: 0, kind: 'image' };
  } finally {
    URL.revokeObjectURL(url);
  }
}

function mimeToExtension(type = '') {
  if (type.includes('jpeg') || type.includes('jpg')) return '.jpg';
  if (type.includes('png')) return '.png';
  if (type.includes('gif')) return '.gif';
  if (type.includes('webp')) return '.webp';
  if (type.includes('mp4')) return '.mp4';
  if (type.includes('quicktime')) return '.mov';
  if (type.includes('webm')) return '.webm';
  return '';
}


function sanitizeSegment(value) {
  return value.toLowerCase().replace(/[^\w-]+/g, '-').replace(/-+/g, '-').replace(/^-+|-+$/g, '');
}

function generateFileName(file, preview = false, templateOverride) {
  const originalName = file.name || '';
  const extMatch = originalName.match(/(\.[\w]+)$/);
  let ext = extMatch ? extMatch[1] : '';
  if (!ext) ext = mimeToExtension(file.type || '');
  const base = originalName.replace(/(\.[\w]+)$/, '') || (file.type?.startsWith('video/') ? 'video' : 'photo');
  const template = (templateOverride && templateOverride.trim()) || (settings.namingScheme && settings.namingScheme.trim()) || defaultSettings.namingScheme;
  const date = new Date(file.lastModified || Date.now());
  const dateStr = date.toISOString().slice(0, 10);
  const timeStr = date.toTimeString().slice(0, 8).replace(/:/g, '-');
  const needsCounter = template.includes('{{counter}}');
  const replacements = {
    original: sanitizeSegment(base) || 'media',
    date: dateStr,
    time: timeStr,
    timestamp: String(date.getTime()),
    counter: needsCounter ? String(settings.counter || 1).padStart(3, '0') : ''
  };
  let result = template;
  for (const [token, value] of Object.entries(replacements)) {
    result = result.split(`{{${token}}}`).join(value);
  }
  result = sanitizeSegment(result) || sanitizeSegment(base) || 'media';
  if (needsCounter && !preview) {
    settings.counter = (settings.counter || 1) + 1;
    saveSettings();
  }
  return ext ? `${result}${ext}` : result;
}

async function refreshGallery() {
  const raw = await idbAll(db, STORE);
  photoCache = raw.map(item => {
    if (item.folderId == null && item.albumId != null) item.folderId = item.albumId;
    if (item.captured == null) item.captured = item.created;
    if (!item.kind) item.kind = item.type?.startsWith('video/') ? 'video' : 'image';
    if (item.duration == null && item.kind === 'video') item.duration = 0;
    if (item.width == null) item.width = 0;
    if (item.height == null) item.height = 0;
    if (item.size == null) item.size = item.blob?.size || 0;
    return item;
  });
  renderFolderList();
  renderGallery();
}

function renderGallery() {
  const isDrive = activeTab === TAB_FOLDERS;
  const container = isDrive ? driveItemsEl : albumMediaEl;
  if (!container) return;
  const driveEmpty = document.getElementById('emptyState');
  const albumEmpty = albumMediaEmptyEl;

  if (isDrive) {
    container.innerHTML = '';
    container.classList.toggle('folder-list-view', driveViewMode === 'list');
    driveShellEl?.classList.toggle('selecting', selectionMode);
    albumEmpty?.classList.add('hidden');
    const parentId = typeof currentFolder === 'number' ? currentFolder : null;
    const counts = photoCache.reduce((acc, item) => {
      const key = item.folderId ?? null;
      acc[key] = (acc[key] || 0) + 1;
      return acc;
    }, {});
    let childFolders = folders.filter(folder => (folder.parentId ?? null) === (parentId ?? null));
    if (driveSearchTerm) {
      const term = driveSearchTerm.toLowerCase();
      childFolders = childFolders.filter(folder => folder.name.toLowerCase().includes(term));
    }
    childFolders.sort((a, b) => a.name.localeCompare(b.name));
    const visibleIds = new Set(childFolders.map(f => f.id));
    selectedFolders.forEach(id => { if (!visibleIds.has(id)) selectedFolders.delete(id); });

    let mediaList = typeof currentFolder === 'number'
      ? photoCache.filter(item => item.folderId === currentFolder)
      : photoCache.filter(item => item.folderId == null);
    if (driveSearchTerm) {
      const term = driveSearchTerm.toLowerCase();
      mediaList = mediaList.filter(item => (item.name || '').toLowerCase().includes(term));
    }
    mediaList = sortPhotos(mediaList);
    currentViewList = mediaList;
    const visibleMediaIds = new Set(mediaList.map(item => item.id));
    selectedMedia = new Set([...selectedMedia].filter(id => visibleMediaIds.has(id)));

    if (!childFolders.length && !mediaList.length) {
      if (driveEmpty) {
        driveEmpty.classList.remove('hidden');
        driveEmpty.innerHTML = driveSearchTerm
          ? `No results match "${driveSearchTerm}".`
          : 'No media in <strong>' + emptyAlbumLabel.textContent + '</strong> yet.';
      }
      updateSelectionChrome();
      return;
    }
    driveEmpty?.classList.add('hidden');
    const fragment = document.createDocumentFragment();
    childFolders.forEach(folder => fragment.appendChild(createFolderCard(folder, counts[folder.id] || 0)));
    mediaList.forEach((item, idx) => fragment.appendChild(createMediaTile(item, idx)));
    container.appendChild(fragment);
    updateSelectionChrome();
    return;
  }

  // Album tab
  container.innerHTML = '';
  driveEmpty?.classList.add('hidden');
  const viewingAlbum = !!currentAlbumId;
  albumMediaPanel?.classList.toggle('hidden', !viewingAlbum);
  albumBackBtn?.classList.toggle('hidden', !viewingAlbum);
  if (!viewingAlbum) {
    albumMediaEmptyEl?.classList.add('hidden');
    currentViewList = [];
    updateSelectionChrome();
    return;
  }
  const ids = albumMembership.get(currentAlbumId);
  if (!ids || !ids.size) {
    albumMediaEmptyEl?.classList.remove('hidden');
    currentViewList = [];
    updateSelectionChrome();
    return;
  }
  albumMediaEmptyEl?.classList.add('hidden');
  let list = photoCache.filter(item => ids.has(item.id));
  list = sortPhotos(list);
  currentViewList = list;
  albumEmpty?.classList.add('hidden');
  list.forEach((item, idx) => {
    const url = URL.createObjectURL(item.blob);
    const isVideo = item.kind === 'video' || item.type?.startsWith('video/');
    const isText = item.kind === 'text' || item.type === 'text/plain';
    const card = document.createElement('div');
    card.className = 'card';
    let mediaEl;
    if (isVideo) {
      mediaEl = document.createElement('video');
      mediaEl.muted = true;
      mediaEl.loop = true;
      mediaEl.autoplay = true;
      mediaEl.playsInline = true;
      mediaEl.src = url;
      mediaEl.onloadeddata = () => URL.revokeObjectURL(url);
      mediaEl.onerror = () => URL.revokeObjectURL(url);
      const flag = document.createElement('span');
      flag.className = 'media-flag';
      flag.textContent = 'üé¨ Video';
      card.appendChild(flag);
    } else if (isText) {
      URL.revokeObjectURL(url);
      mediaEl = document.createElement('div');
      mediaEl.className = 'text-card';
      mediaEl.textContent = item.preview || item.name || 'Text file';
    } else {
      mediaEl = document.createElement('img');
      mediaEl.loading = 'lazy';
      mediaEl.alt = item.name;
      mediaEl.src = url;
      mediaEl.onload = () => URL.revokeObjectURL(url);
      mediaEl.onerror = () => URL.revokeObjectURL(url);
    }
    card.appendChild(mediaEl);
    const meta = document.createElement('div');
    meta.className = 'meta';
    const label = document.createElement('span');
    label.textContent = new Date(item.created).toLocaleString();
    const chip = document.createElement('span');
    chip.className = 'chip';
    chip.textContent = isVideo ? formatDuration(item.duration) : (isText ? 'Text file' : `${item.width}√ó${item.height}`);
    meta.append(label, chip);
    card.appendChild(meta);
    card.addEventListener('click', () => openViewerAt(idx));
    container.appendChild(card);
  });
  updateSelectionChrome();
}

function sortPhotos(list) {
  const sorted = list.slice();
  sorted.sort((a, b) => {
    switch (mediaSortMode) {
      case 'name-asc':
        return (a.name || '').toLowerCase().localeCompare((b.name || '').toLowerCase());
      case 'name-desc':
        return (b.name || '').toLowerCase().localeCompare((a.name || '').toLowerCase());
      case 'size-asc':
        return (a.size || 0) - (b.size || 0);
      case 'size-desc':
        return (b.size || 0) - (a.size || 0);
      case 'created-asc':
        return (a.created || 0) - (b.created || 0);
      case 'created-desc':
      default:
        return (b.created || 0) - (a.created || 0);
    }
  });
  return sorted;
}


function openViewerAt(index) {
  if (!currentViewList.length) return;
  if (index < 0 || index >= currentViewList.length) return;
  currentViewerIndex = index;
  viewMedia(currentViewList[index]);
}

function getCurrentItem() {
  if (currentViewerIndex < 0) return null;
  return currentViewList[currentViewerIndex] || null;
}

function viewMedia(item) {
  if (viewerUrl) {
    if (!viewerVideo.classList.contains('hidden')) {
      viewerVideo.pause();
      viewerVideo.removeAttribute('src');
      viewerVideo.load();
    }
    URL.revokeObjectURL(viewerUrl);
    viewerUrl = null;
  }
  resetZoom();
  toggleChrome(false);
  const url = URL.createObjectURL(item.blob);
  viewerUrl = url;
  const isVideo = item.kind === 'video' || item.type?.startsWith('video/');
  viewerImg.classList.toggle('hidden', isVideo);
  viewerVideo.classList.toggle('hidden', !isVideo);
  if (isVideo) {
    viewerVideo.src = url;
    viewerVideo.currentTime = 0;
    viewerVideo.muted = true;
    viewerVideo.play().catch(()=>{});
    muteToggle.classList.remove('hidden');
    muteToggle.textContent = 'üîá';
  } else {
    viewerImg.src = url;
    viewerImg.alt = item.name;
    muteToggle.classList.add('hidden');
  }
  viewerTitle.textContent = item.name || (isVideo ? 'Video' : 'Photo');
  const captured = new Date(item.captured ?? item.created).toLocaleString();
  const extra = isVideo && item.duration ? ` ‚Ä¢ ${formatDuration(item.duration)}` : ` ‚Ä¢ ${item.width}√ó${item.height}`;
  viewerDetails.textContent = `${captured}${extra}`;
  photoViewer.classList.remove('hidden');
}

function navigateViewer(delta) {
  if (currentViewerIndex === -1) return;
  const nextIndex = currentViewerIndex + delta;
  if (nextIndex < 0 || nextIndex >= currentViewList.length) return;
  openViewerAt(nextIndex);
}

function closeViewer() {
  photoViewer.classList.add('hidden');
  viewerImg.src = '';
  viewerImg.classList.remove('hidden');
  viewerVideo.pause();
  viewerVideo.removeAttribute('src');
  viewerVideo.load();
  viewerVideo.classList.add('hidden');
  muteToggle.classList.add('hidden');
  if (viewerUrl) {
    URL.revokeObjectURL(viewerUrl);
    viewerUrl = null;
  }
  currentViewerIndex = -1;
  chromeHidden = false;
  resetZoom();
  clearTimeout(tapTimeout);
  lastTapTime = 0;
}

viewerClose?.addEventListener('click', closeViewer);
photoViewer?.addEventListener('click', (e) => {
  if (e.target === photoViewer) closeViewer();
});

actionMoveFolder?.addEventListener('click', handleMoveToFolder);
actionAddAlbumBtn?.addEventListener('click', handleAddToAlbum);
actionSave?.addEventListener('click', handleSaveMedia);
actionInfo?.addEventListener('click', handleInfo);

muteToggle?.addEventListener('click', () => {
  if (viewerVideo.classList.contains('hidden')) return;
  viewerVideo.muted = !viewerVideo.muted;
  muteToggle.textContent = viewerVideo.muted ? 'üîá' : 'üîä';
});

viewerMediaEl?.addEventListener('pointerdown', onViewerPointerDown);
viewerMediaEl?.addEventListener('pointermove', onViewerPointerMove);
viewerMediaEl?.addEventListener('pointerup', onViewerPointerUp);
viewerMediaEl?.addEventListener('pointercancel', resetGesture);
viewerMediaEl?.addEventListener('pointerleave', (e) => {
  if (gesture.active && gesture.pointerId === e.pointerId && !gesture.panMode) resetGesture();
});

function toggleChrome(force) {
  chromeHidden = typeof force === 'boolean' ? force : !chromeHidden;
  photoViewer?.classList.toggle('hide-chrome', chromeHidden);
}

function resetZoom() {
  isZoomed = false;
  panX = 0;
  panY = 0;
  applyZoomTransform();
}

function getActiveMediaElement() {
  if (!viewerVideo.classList.contains('hidden')) return viewerVideo;
  return viewerImg;
}

function applyZoomTransform() {
  const target = getActiveMediaElement();
  if (!target) return;
  if (isZoomed) {
    const limit = 200;
    panX = Math.max(Math.min(panX, limit), -limit);
    panY = Math.max(Math.min(panY, limit), -limit);
    target.style.transform = `translate(${panX}px, ${panY}px) scale(2)`;
    target.classList.add('zoomed');
  } else {
    target.style.transform = 'translate(0,0) scale(1)';
    target.classList.remove('zoomed');
  }
}

function toggleZoom(event) {
  const target = getActiveMediaElement();
  if (!target) return;
  isZoomed = !isZoomed;
  if (isZoomed) {
    const rect = target.getBoundingClientRect();
    const originX = ((event?.clientX ?? (rect.left + rect.width / 2)) - rect.left) / rect.width * 100;
    const originY = ((event?.clientY ?? (rect.top + rect.height / 2)) - rect.top) / rect.height * 100;
    target.style.transformOrigin = `${originX}% ${originY}%`;
  } else {
    panX = 0;
    panY = 0;
    target.style.transformOrigin = '50% 50%';
  }
  applyZoomTransform();
}

function handleTap(event) {
  const now = Date.now();
  if (now - lastTapTime < 300) {
    clearTimeout(tapTimeout);
    lastTapTime = 0;
    toggleZoom(event);
  } else {
    lastTapTime = now;
    tapTimeout = setTimeout(() => {
      toggleChrome();
      lastTapTime = 0;
    }, 320);
  }
}

function toggleMenu(menu, button) {
  if (!menu) return;
  const isOpen = menu.classList.contains('show');
  closeMenus();
  if (!isOpen) {
    menu.classList.add('show');
    button?.setAttribute('aria-expanded', 'true');
  }
}

function closeMenus() {
  addMenu?.classList.remove('show');
  moreMenu?.classList.remove('show');
  primaryAddBtn?.setAttribute('aria-expanded', 'false');
  moreActionsBtn?.setAttribute('aria-expanded', 'false');
}

function handleAddAction(action) {
  switch (action) {
    case 'import':
      triggerFileSelect('');
      break;
    case 'folder':
      openCreateModal('folder');
      break;
    case 'text':
      handleTextFileCreate();
      break;
    default:
      break;
  }
}

function triggerFileSelect(accept) {
  if (!input) return;
  const original = input.accept;
  input.accept = accept || 'image/*,video/*';
  input.click();
  setTimeout(() => { input.accept = original; }, 0);
}

async function handleTextFileCreate() {
  const defaultName = 'notes.txt';
  const name = prompt('File name', defaultName);
  if (!name) return;
  const content = prompt('Enter text', '');
  if (content === null) return;
  const blob = new Blob([content], { type: 'text/plain' });
  await addInlineMedia({
    name,
    blob,
    type: 'text/plain'
  });
}

function handleSortSelection(mode) {
  mediaSortMode = mode || 'created-desc';
  renderGallery();
}

function handleViewChange(mode) {
  driveViewMode = mode === 'list' ? 'list' : 'grid';
  renderGallery();
}

function toggleSelectionMode(force) {
  const next = typeof force === 'boolean' ? force : !selectionMode;
  selectionMode = next;
  if (!selectionMode) {
    selectedFolders.clear();
    selectedMedia.clear();
  }
  driveShellEl?.classList.toggle('selecting', selectionMode);
  updateSelectionChrome();
  renderGallery();
}

function onViewerPointerDown(e) {
  if (e.pointerType === 'mouse' && e.button !== 0) return;
  viewerMediaEl.setPointerCapture(e.pointerId);
  gesture.active = true;
  gesture.pointerId = e.pointerId;
  gesture.startX = e.clientX;
  gesture.startY = e.clientY;
  gesture.initialX = e.clientX;
  gesture.initialY = e.clientY;
  gesture.startTime = performance.now();
  gesture.panMode = isZoomed;
}

function onViewerPointerMove(e) {
  if (!gesture.active || gesture.pointerId !== e.pointerId) return;
  if (gesture.panMode && isZoomed) {
    const dx = e.clientX - gesture.startX;
    const dy = e.clientY - gesture.startY;
    panX += dx;
    panY += dy;
    gesture.startX = e.clientX;
    gesture.startY = e.clientY;
    applyZoomTransform();
  }
}

function onViewerPointerUp(e) {
  if (!gesture.active || gesture.pointerId !== e.pointerId) return;
  viewerMediaEl.releasePointerCapture(e.pointerId);
  const totalDx = e.clientX - gesture.initialX;
  const totalDy = e.clientY - gesture.initialY;
  const duration = performance.now() - gesture.startTime;
  if (!gesture.panMode) {
    if (Math.abs(totalDx) > 60 && Math.abs(totalDy) < 120 && duration < 600) {
      navigateViewer(totalDx > 0 ? -1 : 1);
    } else if (Math.abs(totalDx) < 10 && Math.abs(totalDy) < 10) {
      handleTap(e);
    }
  } else if (Math.abs(totalDx) < 10 && Math.abs(totalDy) < 10) {
    handleTap(e);
  }
  resetGesture();
}

function resetGesture() {
  gesture.active = false;
  gesture.pointerId = null;
}

function handleMoveToFolder() {
  const current = getCurrentItem();
  if (!current) return alert('Open a photo or video first.');
  const targetFolder = pickFolderDestination();
  if (targetFolder === undefined) return;
  if ((current.folderId ?? null) === targetFolder) {
    alert('Already in that folder.');
    return;
  }
  idbPut(db, STORE, { ...current, folderId: targetFolder }).then(async () => {
    await refreshGallery();
    await loadFolders();
    closeViewer();
    alert('Moved to ' + (targetFolder ? folderTitleFor(targetFolder) : 'Main Library') + '.');
  });
}

function handleAddToAlbum() {
  const current = getCurrentItem();
  if (!current) return alert('Open a photo or video first.');
  let selected = currentAlbumId;
  if (!selected) {
    const choice = pickAlbumDestination();
    if (choice === undefined) return;
    selected = choice;
  }
  const membership = albumMembership.get(selected) || new Set();
  if (membership.has(current.id)) {
    alert('Already in that album.');
    return;
  }
  const entry = { id: `${selected}-${current.id}`, albumId: selected, photoId: current.id, created: Date.now() };
  idbAdd(db, COLLECTION_ITEMS_STORE, entry).then(async () => {
    if (!albumMembership.has(selected)) albumMembership.set(selected, new Set());
    albumMembership.get(selected).add(current.id);
    renderAlbumGrid();
    if (currentAlbumId === selected) updateHeader();
    if (activeTab === TAB_ALBUMS && currentAlbumId === selected) renderGallery();
    alert('Added to album.');
  }).catch(() => alert('Unable to add to album.'));
}

function handleSaveMedia() {
  const current = getCurrentItem();
  if (!current) return alert('Open a photo or video first.');
  const url = URL.createObjectURL(current.blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = current.name || 'media';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

function handleInfo() {
  const current = getCurrentItem();
  if (!current) return alert('Open a photo or video first.');
  const lines = [
    `Name: ${current.name}`,
    `Type: ${current.type}`,
    `Captured: ${new Date(current.captured ?? current.created).toLocaleString()}`,
    `Uploaded: ${new Date(current.created).toLocaleString()}`,
    current.kind === 'video'
      ? `Duration: ${formatDuration(current.duration)}`
      : `Size: ${current.width}√ó${current.height}`,
    `Folder: ${current.folderId ? folderTitleFor(current.folderId) : 'Main Library'}`
  ];
  alert(lines.join('\n'));
}

document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    if (!modal.classList.contains('hidden')) closeModal();
    if (!settingsModal.classList.contains('hidden')) closeSettings();
    if (!photoViewer.classList.contains('hidden')) closeViewer();
  }
  if (!photoViewer.classList.contains('hidden')) {
    if (e.key === 'ArrowRight') { e.preventDefault(); navigateViewer(1); }
    if (e.key === 'ArrowLeft') { e.preventDefault(); navigateViewer(-1); }
  }
});

clearBtn?.addEventListener('click', async () => {
  if (confirm('Remove all media from this device?')) {
    await idbClear(db, STORE);
    await refreshGallery();
  }
});

exportBtn?.addEventListener('click', exportZip);

async function exportZip() {
  await DB_READY;
  const files = await idbAll(db, STORE);
  if (!files.length) return alert('No media to export.');
  const encoder = new TextEncoder();
  const fileRecords = [];
  let offset = 0;
  const chunks = [];

  function crc32(buf) {
    const table = (function(){
      let c, table = new Uint32Array(256);
      for (let n=0; n<256; n++) { c=n; for (let k=0;k<8;k++) c = (c&1)?(0xEDB88320^(c>>>1)):(c>>>1); table[n]=c>>>0; }
      return table;
    })();
    let crc = 0 ^ (-1);
    for (let i=0; i<buf.length; i++) crc = (crc>>>8) ^ table[(crc ^ buf[i]) & 0xFF];
    return (crc ^ (-1)) >>> 0;
  }

  for (const f of files) {
    const name = (f.name || 'media').replace(/\//g, '_');
    const nameBytes = encoder.encode(name);
    const data = new Uint8Array(await f.blob.arrayBuffer());
    const c = crc32(data);

    const local = new DataView(new ArrayBuffer(30));
    let p=0;
    local.setUint32(p, 0x04034b50, true); p+=4;
    local.setUint16(p, 20, true); p+=2;
    local.setUint16(p, 0, true); p+=2;
    local.setUint16(p, 0, true); p+=2;
    local.setUint16(p, 0, true); p+=2;
    local.setUint16(p, 0, true); p+=2;
    local.setUint32(p, c, true); p+=4;
    local.setUint32(p, data.length, true); p+=4;
    local.setUint32(p, data.length, true); p+=4;
    local.setUint16(p, nameBytes.length, true); p+=2;
    local.setUint16(p, 0, true); p+=2;

    chunks.push(new Uint8Array(local.buffer));
    chunks.push(nameBytes);
    chunks.push(data);

    fileRecords.push({ nameBytes, c, size: data.length, offset });
    offset += 30 + nameBytes.length + data.length;
  }

  const cdChunks = [];
  let cdSize = 0;
  for (const rec of fileRecords) {
    const cd = new DataView(new ArrayBuffer(46));
    let p=0;
    cd.setUint32(p, 0x02014b50, true); p+=4;
    cd.setUint16(p, 20, true); p+=2;
    cd.setUint16(p, 20, true); p+=2;
    cd.setUint16(p, 0, true); p+=2;
    cd.setUint16(p, 0, true); p+=2;
    cd.setUint16(p, 0, true); p+=2;
    cd.setUint16(p, 0, true); p+=2;
    cd.setUint32(p, rec.c, true); p+=4;
    cd.setUint32(p, rec.size, true); p+=4;
    cd.setUint32(p, rec.size, true); p+=4;
    cd.setUint16(p, rec.nameBytes.length, true); p+=2;
    cd.setUint16(p, 0, true); p+=2;
    cd.setUint16(p, 0, true); p+=2;
    cd.setUint16(p, 0, true); p+=2;
    cd.setUint16(p, 0, true); p+=2;
    cd.setUint32(p, 0, true); p+=4;
    cd.setUint32(p, rec.offset, true); p+=4;

    cdChunks.push(new Uint8Array(cd.buffer));
    cdChunks.push(rec.nameBytes);
    cdSize += 46 + rec.nameBytes.length;
  }

  const end = new DataView(new ArrayBuffer(22));
  let q=0;
  end.setUint32(q, 0x06054b50, true); q+=4;
  end.setUint16(q, 0, true); q+=2;
  end.setUint16(q, 0, true); q+=2;
  end.setUint16(q, fileRecords.length, true); q+=2;
  end.setUint16(q, fileRecords.length, true); q+=2;
  end.setUint32(q, cdSize, true); q+=4;
  end.setUint32(q, offset, true); q+=4;
  end.setUint16(q, 0, true); q+=2;

  const blob = new Blob([...chunks, ...cdChunks, new Uint8Array(end.buffer)], { type: 'application/zip' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'media.zip';
  a.click();
  URL.revokeObjectURL(url);
}
</script>
</body>
</html>
