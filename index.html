<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="robots" content="noindex, nofollow" />
  <title>My Photo Album</title>
  <meta name="theme-color" content="#0F172A" />
  <link rel="manifest" href="manifest.webmanifest">
  <link rel="icon" href="icons/icon-192.png">
  <style>
    :root {
      --bg:#050812;
      --card:#0f172a;
      --muted:#94a3b8;
      --text:#f1f5f9;
      --accent:#38bdf8;
      --accent-strong:#0ea5e9;
      --sidebar:#0b1220;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: radial-gradient(circle at top, rgba(56,189,248,.25), transparent 45%), var(--bg);
      color: var(--text);
      min-height: 100vh;
    }
    header {
      position: sticky;
      top: 0;
      z-index: 20;
      backdrop-filter: saturate(180%) blur(10px);
      background: rgba(5,8,18,.9);
      border-bottom: 1px solid rgba(148,163,184,.15);
    }
    .wrap { max-width: 1200px; margin: 0 auto; padding: 12px 16px; }
    .row { display: flex; gap: 12px; align-items: center; }
    h1 { font-size: 18px; margin: 0; letter-spacing: .2px; }
    .spacer { flex: 1; }
    button, label.btn {
      cursor: pointer;
      border: 1px solid rgba(148,163,184,.25);
      background: linear-gradient(180deg, #1e293b, #0f172a);
      color: var(--text);
      padding: 8px 12px;
      border-radius: 12px;
      font-weight: 600;
      transition: border-color .2s ease, transform .2s ease;
    }
    button:hover, label.btn:hover { border-color: rgba(148,163,184,.45); }
    button:active { transform: scale(.98); }
    input[type=file] { display: none; }

    .app-shell { display: flex; gap: 18px; max-width: 1200px; margin: 32px auto; padding: 0 16px 32px; }
    .sidebar {
      width: 260px;
      flex-shrink: 0;
      background: var(--sidebar);
      border: 1px solid rgba(148,163,184,.1);
      border-radius: 20px;
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 16px;
      box-shadow: 0 8px 30px rgba(0,0,0,.35);
    }
    .brand-card { display: flex; align-items: center; gap: 12px; }
    .brand-card .emoji {
      width: 48px;
      height: 48px;
      border-radius: 16px;
      background: rgba(56,189,248,.15);
      display: grid;
      place-items: center;
      font-size: 20px;
    }
    .brand-card strong { display:block; font-size: 16px; }
    .brand-card span { color: var(--muted); font-size: 12px; }
    .btn.wide { width: 100%; text-align: center; }
    .album-list { display: flex; flex-direction: column; gap: 8px; max-height: calc(100vh - 220px); overflow-y: auto; }
    .album-item {
      display: flex;
      align-items: center;
      gap: 12px;
      width: 100%;
      background: rgba(15,23,42,.75);
      border-radius: 16px;
      padding: 10px 12px;
      border: 1px solid transparent;
      text-align: left;
    }
    .album-item .album-icon { font-size: 18px; }
    .album-meta { display: flex; flex-direction: column; font-size: 11px; color: var(--muted); }
    .album-meta strong { font-size: 14px; color: var(--text); }
    .album-item.active { border-color: var(--accent); background: rgba(56,189,248,.12); }

    .workspace {
      flex: 1;
      background: rgba(15,23,42,.75);
      border-radius: 24px;
      border: 1px solid rgba(148,163,184,.1);
      padding: 24px;
      box-shadow: 0 12px 40px rgba(0,0,0,.35);
      min-height: 70vh;
    }
    .album-heading { display:flex; align-items:center; justify-content: space-between; flex-wrap:wrap; gap:12px; margin-bottom: 20px; }
    .eyebrow { margin:0; font-size:11px; text-transform:uppercase; letter-spacing:.2em; color:var(--muted); }
    #activeAlbumTitle { margin:4px 0 0; font-size: 26px; }
    .album-select {
      min-width: 180px;
      background: rgba(15,23,42,.85);
      color: var(--text);
      border: 1px solid rgba(148,163,184,.25);
      border-radius: 12px;
      padding: 8px;
      font-weight:600;
    }
    .sort-toolbar {
      display:flex;
      gap:12px;
      align-items:flex-end;
      flex-wrap:wrap;
      font-size:12px;
      color:var(--muted);
    }
    .sort-toolbar select {
      background: rgba(15,23,42,.85);
      color: var(--text);
      border: 1px solid rgba(148,163,184,.25);
      border-radius: 12px;
      padding: 6px 10px;
      font-weight:600;
    }
    .sort-toolbar button {
      padding:6px 10px;
      border-radius:12px;
    }

    .toolbar { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(180px,1fr)); gap: 12px; margin-top: 18px; }
    .card { position: relative; border-radius: 16px; overflow: hidden; background: var(--card); border: 1px solid rgba(148,163,184,.15); box-shadow: 0 6px 20px rgba(0,0,0,.25); }
    .card img, .card video { display: block; width: 100%; height: 200px; object-fit: cover; background: #111827; }
    .card video { pointer-events: none; }
    .media-flag {
      position:absolute;
      top:8px;
      right:8px;
      background:rgba(5,8,18,.75);
      border-radius:999px;
      padding:4px 8px;
      font-size:12px;
      display:flex;
      align-items:center;
      gap:4px;
    }
    .meta { display:flex; align-items:center; justify-content: space-between; gap:8px; padding: 8px 10px; font-size: 12px; color: var(--muted); }
    .chip { padding: 3px 8px; border-radius: 999px; background: rgba(56,189,248,.12); color: var(--text); border:1px solid rgba(56,189,248,.35); font-weight:600; }
    .empty { text-align:center; color: var(--muted); padding: 60px 16px; border: 1px dashed rgba(148,163,184,.25); border-radius: 18px; margin-top: 24px; }
    .empty strong { color: var(--text); }

    .dropzone { border:2px dashed rgba(148,163,184,.35); border-radius:16px; padding:20px; text-align:center; color: var(--muted); transition: border-color .2s ease, background .2s ease; }
    .dropzone strong { color: var(--text); }
    .dropzone.drag { border-color: var(--accent); background: rgba(56,189,248,.06); color: var(--text); }

    .footer { text-align:center; color: var(--muted); padding: 24px; }
    .hidden { display:none !important; }

    .modal {
      position: fixed;
      inset: 0;
      background: rgba(5,8,18,.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 30;
    }
    .modal-card {
      background: var(--sidebar);
      border-radius: 20px;
      padding: 24px;
      width: min(360px, 90vw);
      border: 1px solid rgba(148,163,184,.2);
      box-shadow: 0 20px 60px rgba(0,0,0,.45);
    }
    .modal-card h3 { margin-top:0; margin-bottom:12px; }
    .modal-card label { display:block; font-size:13px; color:var(--muted); margin-bottom:4px; }
    .modal-card input {
      width: 100%;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(148,163,184,.3);
      background: rgba(15,23,42,.9);
      color: var(--text);
      font-size: 14px;
    }
    .modal-actions { display:flex; justify-content:flex-end; gap:8px; margin-top:18px; }

    @media (max-width: 960px) {
      .app-shell { flex-direction: column; }
      .sidebar { width: 100%; flex-direction: row; flex-wrap: wrap; }
      .album-list { flex-direction: row; flex-wrap: wrap; max-height: none; }
      .album-item { flex: 1 1 160px; }
    }

    .photo-viewer {
      position: fixed;
      inset: 0;
      background: rgba(3,6,15,.95);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 60;
      padding: 0;
      backdrop-filter: blur(6px);
    }
    .photo-viewer .viewer-frame {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      background: transparent;
      border: none;
      padding: 0;
    }
    .viewer-top {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      padding: 16px 16px 0;
      color: var(--text);
      text-shadow: 0 1px 3px rgba(0,0,0,.6);
    }
    .viewer-top-info {
      display: flex;
      flex-direction: column;
      gap: 4px;
      font-size: 13px;
    }
    .viewer-top-info strong {
      font-size: 16px;
    }
    .viewer-top-info span {
      color: var(--muted);
      font-size: 12px;
    }
    .viewer-media {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
      touch-action: none;
    }
    .viewer-media img,
    .viewer-media video {
      width: 100%;
      height: 100%;
      object-fit: contain;
      background: #000;
      transition: transform .2s ease;
    }
    .viewer-media img.zoomed,
    .viewer-media video.zoomed {
      cursor: grab;
    }
    .viewer-actions {
      display: flex;
      justify-content: center;
      gap: 24px;
      padding: 16px;
    }
    .icon-btn {
      background: transparent;
      border: none;
      color: var(--text);
      font-size: 22px;
      padding: 8px;
      border-radius: 50%;
      cursor: pointer;
      transition: opacity .2s ease;
    }
    .icon-btn:hover {
      opacity: .8;
    }
    .photo-viewer.hide-chrome .viewer-top,
    .photo-viewer.hide-chrome .viewer-actions {
      opacity: 0;
      pointer-events: none;
    }
    .photo-viewer.hide-chrome {
      cursor: none;
    }

    .settings-modal .modal-card {
      width: min(420px, 95vw);
    }
    .settings-help {
      font-size:12px;
      color:var(--muted);
      margin-top:8px;
    }
    .settings-preview {
      margin-top:10px;
      padding:10px;
      border-radius:12px;
      background:rgba(15,23,42,.8);
      border:1px solid rgba(148,163,184,.2);
      font-size:13px;
    }
  </style>
</head>
<body>
<header>
  <div class="wrap row">
    <h1>üì∏ My Photo Album</h1>
    <div class="spacer"></div>
    <div class="toolbar">
      <label class="btn" for="fileInput">Add Media</label>
      <input id="fileInput" type="file" accept="image/*,video/*" multiple>
      <button id="settingsBtn" type="button">Settings</button>
      <button id="installBtn" class="hidden">Install</button>
      <button id="exportBtn">Export (.zip)</button>
      <button id="clearBtn" title="Remove all photos">Clear</button>
    </div>
  </div>
</header>

<div class="app-shell">
  <aside class="sidebar">
    <div class="brand-card">
      <div class="emoji">üóÇÔ∏è</div>
      <div>
        <strong>Album Desk</strong>
        <span>Organize folders & stories</span>
      </div>
    </div>
    <button id="newAlbumBtn" class="btn wide" type="button">‚ûï New Album</button>
    <nav id="albumList" class="album-list" aria-label="Albums"></nav>
  </aside>

  <main class="workspace">
    <div class="album-heading">
      <div>
        <p class="eyebrow">Collection</p>
        <h2 id="activeAlbumTitle">All Photos</h2>
      </div>
      <div class="sort-toolbar">
        <label style="display:flex; flex-direction:column; gap:4px;">
          <span>Upload to album</span>
          <select id="albumTarget" class="album-select">
            <option value="">Loose Photos</option>
          </select>
        </label>
        <label style="display:flex; flex-direction:column; gap:4px;">
          <span>Sort photos</span>
          <select id="sortField">
            <option value="created">Upload date</option>
            <option value="captured">Photo date</option>
            <option value="name">Name</option>
          </select>
        </label>
        <button id="sortDirectionBtn" type="button" title="Toggle sort direction">Newest ‚Üì</button>
      </div>
    </div>

    <div id="dropzone" class="dropzone">
      Drag & drop photos or videos here or use <strong>Add Media</strong> ‚Äî they go to <strong id="dropTargetLabel">Loose Photos</strong>.
    </div>

    <section id="gallery" class="grid" aria-live="polite"></section>
    <p id="emptyState" class="empty">
      No media in <strong id="emptyAlbumLabel">All Photos</strong> yet.<br>
      Everything stays on this device (IndexedDB). Works offline.
    </p>
  </main>
</div>

<p class="footer">PWA ‚Ä¢ Offline ‚Ä¢ Installable ‚Ä¢ Client-side storage</p>

<div id="albumModal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="albumModalTitle">
  <div class="modal-card">
    <h3 id="albumModalTitle">Create a new album</h3>
    <form id="albumForm">
      <label for="albumName">Album name</label>
      <input id="albumName" name="albumName" type="text" placeholder="e.g. Summer 2024" required maxlength="60" autocomplete="off">
      <div class="modal-actions">
        <button type="button" id="albumCancel">Cancel</button>
        <button type="submit">Create</button>
      </div>
    </form>
  </div>
</div>

<div id="settingsModal" class="modal hidden settings-modal" role="dialog" aria-modal="true" aria-labelledby="settingsTitle">
  <div class="modal-card">
    <h3 id="settingsTitle">Settings</h3>
    <form id="settingsForm">
      <label for="namingScheme">Naming scheme for new uploads</label>
      <input id="namingScheme" name="namingScheme" type="text" placeholder="{{original}}-{{timestamp}}" maxlength="100">
      <p class="settings-help">Available tokens: <code>{{original}}</code>, <code>{{date}}</code>, <code>{{time}}</code>, <code>{{timestamp}}</code>, <code>{{counter}}</code>. File extension is preserved.</p>
      <div class="settings-preview">
        Preview: <strong id="namingPreview">photo-2024-01-01</strong>
      </div>
      <div class="modal-actions">
        <button type="button" id="settingsCancel">Cancel</button>
        <button type="submit">Save</button>
      </div>
    </form>
  </div>
</div>

<div id="photoViewer" class="photo-viewer hidden" role="dialog" aria-modal="true" aria-labelledby="viewerTitle">
  <div class="viewer-frame">
    <div class="viewer-top">
      <div class="viewer-top-info">
        <strong id="viewerTitle"></strong>
        <span id="viewerDetails"></span>
      </div>
      <button id="viewerClose" type="button" class="icon-btn" title="Close">‚úï</button>
    </div>
    <div class="viewer-media" id="viewerMedia">
      <img id="viewerImage" alt="">
      <video id="viewerVideo" class="hidden" playsinline></video>
    </div>
    <div class="viewer-actions">
      <button id="actionAddAlbum" type="button" class="icon-btn" title="Add to album">üìÅ</button>
      <button id="actionSave" type="button" class="icon-btn" title="Save to device">‚¨áÔ∏è</button>
      <button id="actionInfo" type="button" class="icon-btn" title="Details">‚ÑπÔ∏è</button>
      <button id="muteToggle" type="button" class="icon-btn hidden" title="Mute/unmute">üîá</button>
    </div>
  </div>
</div>

<script>
const basePath = "/pwa-photo-gallery/";

// Register service worker
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register(basePath + 'sw.js').catch(console.error);
  });
}

// Install prompt UX
let deferredPrompt;
const installBtn = document.getElementById('installBtn');
window.addEventListener('beforeinstallprompt', (e) => {
  e.preventDefault();
  deferredPrompt = e;
  installBtn.classList.remove('hidden');
});
installBtn?.addEventListener('click', async () => {
  if (!deferredPrompt) return;
  deferredPrompt.prompt();
  await deferredPrompt.userChoice;
  deferredPrompt = null;
  installBtn.classList.add('hidden');
});

// --- Tiny IndexedDB helper ---
function idbOpen(dbName, version) {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(dbName, version);
    req.onupgradeneeded = (event) => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) {
        const store = db.createObjectStore(STORE, { keyPath: 'id', autoIncrement: true });
        store.createIndex('created', 'created');
        store.createIndex('albumId', 'albumId');
      } else if (event.oldVersion < 2) {
        const txStore = req.transaction.objectStore(STORE);
        if (!txStore.indexNames.contains('albumId')) {
          txStore.createIndex('albumId', 'albumId');
        }
      }
      if (!db.objectStoreNames.contains(ALBUM_STORE)) {
        const albumStore = db.createObjectStore(ALBUM_STORE, { keyPath: 'id', autoIncrement: true });
        albumStore.createIndex('name', 'name', { unique: false });
      }
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}
function idbAdd(db, store, value) {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(store, 'readwrite');
    const req = tx.objectStore(store).add(value);
    tx.oncomplete = () => resolve(req.result);
    tx.onerror = () => reject(tx.error);
  });
}
function idbPut(db, store, value) {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(store, 'readwrite');
    tx.objectStore(store).put(value);
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
}
function idbAll(db, store) {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(store, 'readonly');
    const req = tx.objectStore(store).getAll();
    req.onsuccess = () => resolve(req.result || []);
    req.onerror = () => reject(req.error);
  });
}
function idbClear(db, store) {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(store, 'readwrite');
    tx.objectStore(store).clear();
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
}

const DB_NAME = 'pwa-photo-album';
const DB_VERSION = 2;
const STORE = 'photos';
const ALBUM_STORE = 'albums';
const SPECIAL_ALL = 'all';
const SPECIAL_UNSORTED = 'unsorted';
let db;
let albums = [];
let photoCache = [];
let currentAlbum = SPECIAL_ALL;

const albumListEl = document.getElementById('albumList');
const albumTitleEl = document.getElementById('activeAlbumTitle');
const albumSelectEl = document.getElementById('albumTarget');
const emptyAlbumLabel = document.getElementById('emptyAlbumLabel');
const dropTargetLabel = document.getElementById('dropTargetLabel');
const modal = document.getElementById('albumModal');
const albumForm = document.getElementById('albumForm');
const albumInput = document.getElementById('albumName');
const albumCancel = document.getElementById('albumCancel');
const newAlbumBtn = document.getElementById('newAlbumBtn');
const sortFieldEl = document.getElementById('sortField');
const sortDirectionBtn = document.getElementById('sortDirectionBtn');
const settingsBtn = document.getElementById('settingsBtn');
const settingsModal = document.getElementById('settingsModal');
const settingsForm = document.getElementById('settingsForm');
const settingsCancel = document.getElementById('settingsCancel');
const namingInput = document.getElementById('namingScheme');
const namingPreview = document.getElementById('namingPreview');
const photoViewer = document.getElementById('photoViewer');
const viewerClose = document.getElementById('viewerClose');
const viewerImg = document.getElementById('viewerImage');
const viewerVideo = document.getElementById('viewerVideo');
const viewerTitle = document.getElementById('viewerTitle');
const viewerDetails = document.getElementById('viewerDetails');
const viewerMediaEl = document.getElementById('viewerMedia');
const actionAddAlbum = document.getElementById('actionAddAlbum');
const actionSave = document.getElementById('actionSave');
const actionInfo = document.getElementById('actionInfo');
const muteToggle = document.getElementById('muteToggle');
let viewerUrl;
let currentViewList = [];
let currentViewerIndex = -1;
let currentSortField = sortFieldEl?.value || 'created';
const defaultSortAscending = { created: false, captured: false, name: true };
let sortAscending = defaultSortAscending[currentSortField] ?? false;
const SETTINGS_KEY = 'pwa-photo-gallery-settings';
const defaultSettings = { namingScheme: '{{original}}', counter: 1 };
let settings = loadSettings();
let chromeHidden = false;
let isZoomed = false;
let panX = 0;
let panY = 0;
let lastTapTime = 0;
let tapTimeout;
const gesture = { active: false, pointerId: null, startX: 0, startY: 0, initialX: 0, initialY: 0, panMode: false, startTime: 0 };

(async () => {
  db = await idbOpen(DB_NAME, DB_VERSION);
  await ensureAlbumSeed();
  await loadAlbums();
  await refreshGallery();
})();

async function ensureAlbumSeed() {
  const existing = await idbAll(db, ALBUM_STORE);
  if (!existing.length) {
    await idbAdd(db, ALBUM_STORE, { name: 'My First Album', created: Date.now() });
  }
}

async function loadAlbums() {
  albums = await idbAll(db, ALBUM_STORE);
  albums.sort((a, b) => a.name.localeCompare(b.name));
  renderAlbumSelect();
  renderAlbumList();
  updateActiveAlbumUI();
}

function renderAlbumSelect() {
  if (!albumSelectEl) return;
  const prev = albumSelectEl.value;
  albumSelectEl.innerHTML = '';
  const looseOpt = document.createElement('option');
  looseOpt.value = '';
  looseOpt.textContent = 'Loose Photos';
  albumSelectEl.appendChild(looseOpt);
  for (const album of albums) {
    const opt = document.createElement('option');
    opt.value = String(album.id);
    opt.textContent = album.name;
    albumSelectEl.appendChild(opt);
  }
  if (typeof currentAlbum === 'number') {
    albumSelectEl.value = String(currentAlbum);
  } else {
    albumSelectEl.value = '';
  }
  if (!albumSelectEl.value) {
    albumSelectEl.value = '';
  }
  updateDropHint();
}

function renderAlbumList() {
  if (!albumListEl) return;
  albumListEl.innerHTML = '';
  const counts = photoCache.reduce((acc, photo) => {
    const key = photo.albumId ?? SPECIAL_UNSORTED;
    acc[key] = (acc[key] || 0) + 1;
    return acc;
  }, {});
  const entries = [
    { id: SPECIAL_ALL, name: 'All Photos', icon: 'üóÇÔ∏è', count: photoCache.length },
    { id: SPECIAL_UNSORTED, name: 'Loose Photos', icon: 'üì•', count: counts[SPECIAL_UNSORTED] || 0 }
  ];
  for (const album of albums) {
    entries.push({ id: album.id, name: album.name, icon: 'üìÅ', count: counts[album.id] || 0 });
  }
  for (const entry of entries) {
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'album-item' + (isAlbumActive(entry.id) ? ' active' : '');
    btn.dataset.album = String(entry.id);
    btn.setAttribute('aria-pressed', isAlbumActive(entry.id));

    const icon = document.createElement('span');
    icon.className = 'album-icon';
    icon.textContent = entry.icon;

    const meta = document.createElement('div');
    meta.className = 'album-meta';
    const title = document.createElement('strong');
    title.textContent = entry.name;
    const count = document.createElement('span');
    const n = entry.count || 0;
    count.textContent = n ? `${n} photo${n === 1 ? '' : 's'}` : 'Empty';
    meta.append(title, count);

    btn.append(icon, meta);
    albumListEl.appendChild(btn);
  }
}

function isAlbumActive(id) {
  if (typeof id === 'number') return typeof currentAlbum === 'number' && currentAlbum === id;
  return currentAlbum === id;
}

albumListEl?.addEventListener('click', (event) => {
  const target = event.target.closest('button[data-album]');
  if (!target) return;
  const value = target.dataset.album;
  if (!value) return;
  if (value === SPECIAL_ALL || value === SPECIAL_UNSORTED) {
    setActiveAlbum(value);
  } else {
    setActiveAlbum(Number(value));
  }
});

function setActiveAlbum(value) {
  currentAlbum = value;
  if (!photoViewer.classList.contains('hidden')) closeViewer();
  renderAlbumList();
  updateActiveAlbumUI();
  renderGallery();
}

function updateActiveAlbumUI() {
  if (albumTitleEl) albumTitleEl.textContent = albumTitleFor(currentAlbum);
  if (emptyAlbumLabel) emptyAlbumLabel.textContent = albumTitleFor(currentAlbum);
  if (typeof currentAlbum === 'number') {
    albumSelectEl.value = String(currentAlbum);
  } else {
    albumSelectEl.value = '';
  }
  updateDropHint();
}

function albumTitleFor(id) {
  if (id === SPECIAL_ALL) return 'All Photos';
  if (id === SPECIAL_UNSORTED) return 'Loose Photos';
  const found = albums.find(a => a.id === Number(id));
  return found?.name || 'Album';
}

function updateDropHint() {
  if (!dropTargetLabel) return;
  const value = albumSelectEl?.value;
  if (!value) {
    dropTargetLabel.textContent = 'Loose Photos';
  } else {
    const album = albums.find(a => String(a.id) === value);
    dropTargetLabel.textContent = album?.name || 'Selected Album';
  }
}

function updateSortButtonLabel() {
  if (!sortDirectionBtn) return;
  const labels = {
    created: sortAscending ? 'Oldest ‚Üë' : 'Newest ‚Üì',
    captured: sortAscending ? 'Oldest photo ‚Üë' : 'Newest photo ‚Üì',
    name: sortAscending ? 'A‚ÜíZ ‚Üë' : 'Z‚ÜíA ‚Üì'
  };
  sortDirectionBtn.textContent = labels[currentSortField] || (sortAscending ? 'Asc ‚Üë' : 'Desc ‚Üì');
}

function loadSettings() {
  try {
    const raw = JSON.parse(localStorage.getItem(SETTINGS_KEY) || '{}');
    return { ...defaultSettings, ...raw };
  } catch {
    return { ...defaultSettings };
  }
}

function saveSettings() {
  try {
    localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
  } catch (err) {
    console.warn('Unable to persist settings', err);
  }
}

function updateNamingPreview() {
  if (!namingPreview) return;
  const fakeFile = { name: 'IMG_1234.jpg', type: 'image/jpeg', lastModified: Date.now() };
  const template = namingInput?.value || settings.namingScheme;
  namingPreview.textContent = generateFileName(fakeFile, true, template);
}

albumSelectEl?.addEventListener('change', () => {
  updateDropHint();
  if (albumSelectEl.value) {
    setActiveAlbum(Number(albumSelectEl.value));
  } else if (currentAlbum !== SPECIAL_UNSORTED) {
    setActiveAlbum(SPECIAL_UNSORTED);
  }
});

sortFieldEl?.addEventListener('change', () => {
  currentSortField = sortFieldEl.value || 'created';
  sortAscending = defaultSortAscending[currentSortField] ?? false;
  updateSortButtonLabel();
  if (!photoViewer.classList.contains('hidden')) closeViewer();
  renderGallery();
});

sortDirectionBtn?.addEventListener('click', () => {
  sortAscending = !sortAscending;
  updateSortButtonLabel();
  if (!photoViewer.classList.contains('hidden')) closeViewer();
  renderGallery();
});

updateSortButtonLabel();
if (namingInput) namingInput.value = settings.namingScheme || defaultSettings.namingScheme;
updateNamingPreview();

newAlbumBtn?.addEventListener('click', () => {
  modal.classList.remove('hidden');
  albumInput.value = '';
  setTimeout(() => albumInput.focus(), 10);
});

settingsBtn?.addEventListener('click', () => {
  namingInput.value = settings.namingScheme || defaultSettings.namingScheme;
  updateNamingPreview();
  settingsModal.classList.remove('hidden');
  setTimeout(() => namingInput.focus(), 10);
});

settingsCancel?.addEventListener('click', closeSettings);
settingsModal?.addEventListener('click', (e) => {
  if (e.target === settingsModal) closeSettings();
});
settingsForm?.addEventListener('submit', (e) => {
  e.preventDefault();
  settings.namingScheme = namingInput.value.trim() || defaultSettings.namingScheme;
  saveSettings();
  updateNamingPreview();
  closeSettings();
});
namingInput?.addEventListener('input', updateNamingPreview);

albumCancel?.addEventListener('click', closeModal);
modal?.addEventListener('click', (e) => {
  if (e.target === modal) closeModal();
});
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    if (!modal.classList.contains('hidden')) closeModal();
    if (!settingsModal.classList.contains('hidden')) closeSettings();
    if (!photoViewer.classList.contains('hidden')) closeViewer();
  }
  if (!photoViewer.classList.contains('hidden')) {
    if (e.key === 'ArrowRight') {
      e.preventDefault();
      navigateViewer(1);
    } else if (e.key === 'ArrowLeft') {
      e.preventDefault();
      navigateViewer(-1);
    }
  }
});

albumForm?.addEventListener('submit', async (e) => {
  e.preventDefault();
  const name = albumInput.value.trim();
  if (!name) return;
  const id = await idbAdd(db, ALBUM_STORE, { name, created: Date.now() });
  closeModal();
  await loadAlbums();
  setActiveAlbum(Number(id));
});

function closeModal() {
  modal.classList.add('hidden');
}

function closeSettings() {
  settingsModal.classList.add('hidden');
}

const DB_READY = (async () => {
  while (!db) await new Promise(r => setTimeout(r, 50));
})();

const input = document.getElementById('fileInput');
const dz = document.getElementById('dropzone');

input.addEventListener('change', async (e) => {
  await addFiles(e.target.files);
  input.value = '';
});

;['dragenter','dragover'].forEach(evt => dz.addEventListener(evt, (e)=>{ e.preventDefault(); dz.classList.add('drag'); }));
;['dragleave','drop'].forEach(evt => dz.addEventListener(evt, (e)=>{ e.preventDefault(); dz.classList.remove('drag'); }));

dz.addEventListener('drop', async (e) => {
  const files = e.dataTransfer.files;
  await addFiles(files);
});

async function addFiles(fileList) {
  if (!fileList || !fileList.length) return;
  await DB_READY;
  const targetAlbum = albumSelectEl?.value ? Number(albumSelectEl.value) : null;
  const arr = Array.from(fileList).filter(isSupportedFile);
  if (!arr.length) return;
  for (const file of arr) {
    const arrayBuf = await file.arrayBuffer();
    const blob = new Blob([arrayBuf], { type: file.type || 'image/jpeg' });
    const created = Date.now();
    const captured = file.lastModified ? Number(file.lastModified) : created;
    const meta = await getMediaMeta(blob, blob.type || file.type || 'image/jpeg');
    const safeName = generateFileName(file);
    await idbAdd(db, STORE, {
      blob,
      name: safeName,
      type: blob.type || file.type || 'image/jpeg',
      created,
      captured,
      width: meta.width || 0,
      height: meta.height || 0,
      duration: meta.duration || 0,
      kind: meta.kind || 'image',
      albumId: targetAlbum
    });
  }
  await refreshGallery();
}

function imgSize(url) {
  return new Promise((res, rej) => { const i = new Image(); i.onload = ()=>res({width:i.naturalWidth, height:i.naturalHeight}); i.onerror=rej; i.src=url; });
}

function videoMeta(url) {
  return new Promise((resolve, reject) => {
    const video = document.createElement('video');
    video.preload = 'metadata';
    video.muted = true;
    video.onloadedmetadata = () => {
      resolve({
        width: video.videoWidth || 0,
        height: video.videoHeight || 0,
        duration: video.duration || 0
      });
      video.remove();
    };
    video.onerror = (err) => { video.remove(); reject(err || new Error('Video metadata error')); };
    video.src = url;
  });
}

function isSupportedFile(file) {
  const type = file.type || '';
  if (type.startsWith('image/') || type.startsWith('video/')) return true;
  const name = file.name?.toLowerCase() || '';
  return /\.(png|jpg|jpeg|gif|webp|mp4|mov|webm)$/i.test(name);
}

async function getMediaMeta(blob, type) {
  const url = URL.createObjectURL(blob);
  try {
    const mime = type || 'image/jpeg';
    if (mime.startsWith('video/')) {
      try {
        const meta = await videoMeta(url);
        return { ...meta, kind: 'video' };
      } catch {
        return { width: 0, height: 0, duration: 0, kind: 'video' };
      }
    }
    const meta = await imgSize(url);
    return { width: meta.width, height: meta.height, duration: 0, kind: 'image' };
  } finally {
    URL.revokeObjectURL(url);
  }
}

function formatDuration(seconds = 0) {
  if (!seconds || !Number.isFinite(seconds)) return '0:00';
  const total = Math.round(seconds);
  const mins = Math.floor(total / 60);
  const secs = String(total % 60).padStart(2, '0');
  return `${mins}:${secs}`;
}

function sanitizeSegment(value) {
  return value.toLowerCase().replace(/[^\w-]+/g, '-').replace(/-+/g, '-').replace(/^-+|-+$/g, '');
}

function mimeToExtension(type = '') {
  if (type.includes('jpeg') || type.includes('jpg')) return '.jpg';
  if (type.includes('png')) return '.png';
  if (type.includes('gif')) return '.gif';
  if (type.includes('webp')) return '.webp';
  if (type.includes('mp4')) return '.mp4';
  if (type.includes('quicktime')) return '.mov';
  if (type.includes('webm')) return '.webm';
  return '';
}

function generateFileName(file, preview = false, templateOverride) {
  const originalName = file.name || '';
  const extMatch = originalName.match(/(\.[\w]+)$/);
  let ext = extMatch ? extMatch[1] : '';
  if (!ext) {
    ext = mimeToExtension(file.type);
  }
  const base = originalName.replace(/(\.[\w]+)$/, '') || (file.type?.startsWith('video/') ? 'video' : 'photo');
  const template = (templateOverride && templateOverride.trim()) || (settings.namingScheme && settings.namingScheme.trim()) || defaultSettings.namingScheme;
  const date = new Date(file.lastModified || Date.now());
  const dateStr = date.toISOString().slice(0, 10);
  const timeStr = date.toTimeString().slice(0, 8).replace(/:/g, '-');
  const counterNeeded = template.includes('{{counter}}');
  const counterValue = counterNeeded ? String(settings.counter || 1).padStart(3, '0') : '';
  let result = template;
  const replacements = {
    original: sanitizeSegment(base) || 'media',
    date: dateStr,
    time: timeStr,
    timestamp: String(date.getTime()),
    counter: counterValue
  };
  for (const [token, value] of Object.entries(replacements)) {
    result = result.split(`{{${token}}}`).join(value);
  }
  result = sanitizeSegment(result) || sanitizeSegment(base) || 'media';
  if (counterNeeded && !preview) {
    settings.counter = (settings.counter || 1) + 1;
    saveSettings();
  }
  return ext ? `${result}${ext}` : result;
}

async function refreshGallery() {
  const raw = await idbAll(db, STORE);
  photoCache = raw.map(item => {
    if (item.captured == null) item.captured = item.created;
    if (!item.kind) item.kind = item.type?.startsWith('video/') ? 'video' : 'image';
    if (item.duration == null) item.duration = item.kind === 'video' ? 0 : undefined;
    if (item.width == null) item.width = 0;
    if (item.height == null) item.height = 0;
    return item;
  });
  renderGallery();
  renderAlbumList();
}

function renderGallery() {
  const g = document.getElementById('gallery');
  const empty = document.getElementById('emptyState');
  g.innerHTML = '';
  let list = photoCache.slice();
  if (typeof currentAlbum === 'number') {
    list = list.filter(item => item.albumId === currentAlbum);
  } else if (currentAlbum === SPECIAL_UNSORTED) {
    list = list.filter(item => item.albumId == null);
  }
  list = sortPhotos(list);
  currentViewList = list;
  if (!list.length) {
    empty.classList.remove('hidden');
    return;
  }
  empty.classList.add('hidden');

  list.forEach((it, idx) => {
    const url = URL.createObjectURL(it.blob);
    const isVideo = (it.kind === 'video') || it.type?.startsWith('video/');
    const card = document.createElement('div');
    card.className = 'card';

    let mediaEl;
    if (isVideo) {
      mediaEl = document.createElement('video');
      mediaEl.muted = true;
      mediaEl.loop = true;
      mediaEl.autoplay = true;
      mediaEl.playsInline = true;
      mediaEl.src = url;
      mediaEl.onloadeddata = () => URL.revokeObjectURL(url);
      mediaEl.onerror = () => URL.revokeObjectURL(url);
      const flag = document.createElement('span');
      flag.className = 'media-flag';
      flag.textContent = 'üé¨ Video';
      card.appendChild(flag);
    } else {
      mediaEl = document.createElement('img');
      mediaEl.loading = 'lazy';
      mediaEl.alt = it.name;
      mediaEl.src = url;
      mediaEl.onload = () => URL.revokeObjectURL(url);
      mediaEl.onerror = () => URL.revokeObjectURL(url);
    }
    card.appendChild(mediaEl);

    const meta = document.createElement('div');
    meta.className = 'meta';
    const label = document.createElement('span');
    label.textContent = new Date(it.created).toLocaleString();
    const chip = document.createElement('span');
    chip.className = 'chip';
    chip.textContent = isVideo ? formatDuration(it.duration) : `${it.width}√ó${it.height}`;
    meta.append(label, chip);
    card.appendChild(meta);

    card.addEventListener('click', () => openViewerAt(idx));
    g.appendChild(card);
  });
}

function sortPhotos(list) {
  const field = currentSortField || 'created';
  const dir = sortAscending ? 1 : -1;
  const normalized = list.slice();
  const getValue = (item) => {
    if (field === 'name') return (item.name || '').toLowerCase();
    if (field === 'captured') return item.captured ?? item.created;
    return item.created;
  };
  normalized.sort((a, b) => {
    const va = getValue(a);
    const vb = getValue(b);
    if (typeof va === 'string' || typeof vb === 'string') {
      if (va === vb) return 0;
      return va > vb ? dir : -dir;
    }
    if (va === vb) return 0;
    return dir * (va - vb);
  });
  return normalized;
}

function openViewerAt(index) {
  if (!currentViewList.length) return;
  if (index < 0 || index >= currentViewList.length) return;
  currentViewerIndex = index;
  viewMedia(currentViewList[index]);
}

function viewMedia(item) {
  if (viewerUrl) {
    if (!viewerVideo.classList.contains('hidden')) {
      viewerVideo.pause();
      viewerVideo.removeAttribute('src');
      viewerVideo.load();
    }
    URL.revokeObjectURL(viewerUrl);
    viewerUrl = null;
  }
  resetZoom();
  toggleChrome(false);
  const url = URL.createObjectURL(item.blob);
  viewerUrl = url;
  const isVideo = (item.kind === 'video') || item.type?.startsWith('video/');
  viewerImg.classList.toggle('hidden', isVideo);
  viewerVideo.classList.toggle('hidden', !isVideo);
  if (isVideo) {
    viewerVideo.src = url;
    viewerVideo.currentTime = 0;
    viewerVideo.muted = true;
    viewerVideo.play().catch(()=>{});
    muteToggle.classList.remove('hidden');
    muteToggle.textContent = 'üîá';
  } else {
    viewerImg.src = url;
    viewerImg.alt = item.name;
    muteToggle.classList.add('hidden');
  }
  viewerTitle.textContent = item.name || (isVideo ? 'Video' : 'Photo');
  const captured = new Date(item.captured ?? item.created).toLocaleString();
  const extra = isVideo && item.duration ? ` ‚Ä¢ ${formatDuration(item.duration)}` : ` ‚Ä¢ ${item.width}√ó${item.height}`;
  viewerDetails.textContent = `${captured}${extra}`;
  photoViewer.classList.remove('hidden');
}

function getCurrentItem() {
  if (currentViewerIndex < 0) return null;
  return currentViewList[currentViewerIndex] || null;
}

function navigateViewer(delta) {
  if (currentViewerIndex === -1) return;
  const nextIndex = currentViewerIndex + delta;
  if (nextIndex < 0 || nextIndex >= currentViewList.length) return;
  openViewerAt(nextIndex);
}

function closeViewer() {
  photoViewer.classList.add('hidden');
  viewerImg.src = '';
  viewerImg.classList.remove('hidden');
  if (viewerVideo) {
    viewerVideo.pause();
    viewerVideo.removeAttribute('src');
    viewerVideo.load();
    viewerVideo.classList.add('hidden');
  }
  muteToggle?.classList.add('hidden');
  if (viewerUrl) {
    URL.revokeObjectURL(viewerUrl);
    viewerUrl = null;
  }
  currentViewerIndex = -1;
  chromeHidden = false;
  resetZoom();
  clearTimeout(tapTimeout);
  lastTapTime = 0;
}

viewerClose?.addEventListener('click', closeViewer);
photoViewer?.addEventListener('click', (e) => {
  if (e.target === photoViewer) closeViewer();
});
muteToggle?.addEventListener('click', () => {
  if (viewerVideo.classList.contains('hidden')) return;
  viewerVideo.muted = !viewerVideo.muted;
  muteToggle.textContent = viewerVideo.muted ? 'üîá' : 'üîä';
});
actionAddAlbum?.addEventListener('click', handleAddToAlbum);
actionSave?.addEventListener('click', handleSaveMedia);
actionInfo?.addEventListener('click', handleInfo);

viewerMediaEl?.addEventListener('pointerdown', onViewerPointerDown);
viewerMediaEl?.addEventListener('pointermove', onViewerPointerMove);
viewerMediaEl?.addEventListener('pointerup', onViewerPointerUp);
viewerMediaEl?.addEventListener('pointercancel', resetGesture);
viewerMediaEl?.addEventListener('pointerleave', (e) => {
  if (gesture.active && gesture.pointerId === e.pointerId && !gesture.panMode) {
    resetGesture();
  }
});

function onViewerPointerDown(e) {
  if (e.pointerType === 'mouse' && e.button !== 0) return;
  viewerMediaEl.setPointerCapture(e.pointerId);
  gesture.active = true;
  gesture.pointerId = e.pointerId;
  gesture.startX = e.clientX;
  gesture.startY = e.clientY;
  gesture.initialX = e.clientX;
  gesture.initialY = e.clientY;
  gesture.startTime = performance.now();
  gesture.panMode = isZoomed;
}

function onViewerPointerMove(e) {
  if (!gesture.active || gesture.pointerId !== e.pointerId) return;
  if (gesture.panMode && isZoomed) {
    const dx = e.clientX - gesture.startX;
    const dy = e.clientY - gesture.startY;
    panX += dx;
    panY += dy;
    gesture.startX = e.clientX;
    gesture.startY = e.clientY;
    applyZoomTransform();
  }
}

function onViewerPointerUp(e) {
  if (!gesture.active || gesture.pointerId !== e.pointerId) return;
  viewerMediaEl.releasePointerCapture(e.pointerId);
  const totalDx = e.clientX - gesture.initialX;
  const totalDy = e.clientY - gesture.initialY;
  const duration = performance.now() - gesture.startTime;
  if (!gesture.panMode) {
    if (Math.abs(totalDx) > 60 && Math.abs(totalDy) < 120 && duration < 600) {
      navigateViewer(totalDx > 0 ? -1 : 1);
    } else if (Math.abs(totalDx) < 10 && Math.abs(totalDy) < 10) {
      handleTap(e);
    }
  } else if (Math.abs(totalDx) < 10 && Math.abs(totalDy) < 10) {
    handleTap(e);
  }
  resetGesture();
}

function resetGesture() {
  gesture.active = false;
  gesture.pointerId = null;
}

function toggleChrome(force) {
  chromeHidden = typeof force === 'boolean' ? force : !chromeHidden;
  photoViewer?.classList.toggle('hide-chrome', chromeHidden);
}

function resetZoom() {
  isZoomed = false;
  panX = 0;
  panY = 0;
  applyZoomTransform();
}

function getActiveMediaElement() {
  if (viewerVideo && !viewerVideo.classList.contains('hidden')) return viewerVideo;
  return viewerImg;
}

function applyZoomTransform() {
  const target = getActiveMediaElement();
  if (!target) return;
  if (isZoomed) {
    const limit = 200;
    panX = Math.max(Math.min(panX, limit), -limit);
    panY = Math.max(Math.min(panY, limit), -limit);
    target.style.transform = `translate(${panX}px, ${panY}px) scale(2)`;
    target.classList.add('zoomed');
  } else {
    target.style.transform = 'translate(0,0) scale(1)';
    target.classList.remove('zoomed');
  }
}

function toggleZoom(event) {
  const target = getActiveMediaElement();
  if (!target) return;
  isZoomed = !isZoomed;
  if (isZoomed) {
    const rect = target.getBoundingClientRect();
    const originX = ((event?.clientX ?? (rect.left + rect.width / 2)) - rect.left) / rect.width * 100;
    const originY = ((event?.clientY ?? (rect.top + rect.height / 2)) - rect.top) / rect.height * 100;
    target.style.transformOrigin = `${originX}% ${originY}%`;
  } else {
    panX = 0;
    panY = 0;
    target.style.transformOrigin = '50% 50%';
  }
  applyZoomTransform();
}

function handleTap(event) {
  const now = Date.now();
  if (now - lastTapTime < 300) {
    clearTimeout(tapTimeout);
    lastTapTime = 0;
    toggleZoom(event);
  } else {
    lastTapTime = now;
    tapTimeout = setTimeout(() => {
      toggleChrome();
      lastTapTime = 0;
    }, 320);
  }
}

async function handleAddToAlbum() {
  const current = getCurrentItem();
  if (!current) return alert('Open a photo or video first.');
  if (!albumSelectEl) return alert('No album selector available.');
  const selection = albumSelectEl.value;
  if (selection === '' && current.albumId == null) {
    alert('Already in Loose Photos.');
    return;
  }
  if (!selection && selection !== '') {
    alert('Choose an album from the ‚ÄúUpload to album‚Äù dropdown first.');
    return;
  }
  const albumId = selection ? Number(selection) : null;
  await idbPut(db, STORE, { ...current, albumId });
  await refreshGallery();
  closeViewer();
  const label = selection ? albumTitleFor(Number(selection)) : albumTitleFor(SPECIAL_UNSORTED);
  alert(`Moved to ${label}.`);
}

function handleSaveMedia() {
  const current = getCurrentItem();
  if (!current) return alert('Open a photo or video first.');
  const url = URL.createObjectURL(current.blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = current.name || 'media';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

function handleInfo() {
  const current = getCurrentItem();
  if (!current) return alert('Open a photo or video first.');
  const lines = [
    `Name: ${current.name}`,
    `Type: ${current.type}`,
    `Captured: ${new Date(current.captured ?? current.created).toLocaleString()}`,
    `Uploaded: ${new Date(current.created).toLocaleString()}`,
    current.kind === 'video'
      ? `Duration: ${formatDuration(current.duration)}`
      : `Size: ${current.width}√ó${current.height}`,
    `Album: ${current.albumId ? albumTitleFor(current.albumId) : albumTitleFor(SPECIAL_UNSORTED)}`
  ];
  alert(lines.join('\n'));
}

// Export all photos as a .zip (no server)
async function exportZip() {
  await DB_READY;
  const files = await idbAll(db, STORE);
  if (!files.length) return alert('No photos to export.');
  const encoder = new TextEncoder();
  const fileRecords = [];
  let offset = 0;
  const chunks = [];

  function crc32(buf) {
    const table = (function(){
      let c, table = new Uint32Array(256);
      for (let n=0; n<256; n++) { c=n; for (let k=0;k<8;k++) c = (c&1)?(0xEDB88320^(c>>>1)):(c>>>1); table[n]=c>>>0; }
      return table;
    })();
    let crc = 0 ^ (-1);
    for (let i=0; i<buf.length; i++) crc = (crc>>>8) ^ table[(crc ^ buf[i]) & 0xFF];
    return (crc ^ (-1)) >>> 0;
  }

  for (const f of files) {
    const name = (f.name || 'photo').replace(/\//g, '_');
    const nameBytes = encoder.encode(name);
    const data = new Uint8Array(await f.blob.arrayBuffer());
    const c = crc32(data);

    const local = new DataView(new ArrayBuffer(30));
    let p=0;
    local.setUint32(p, 0x04034b50, true); p+=4;
    local.setUint16(p, 20, true); p+=2;
    local.setUint16(p, 0, true); p+=2;
    local.setUint16(p, 0, true); p+=2;
    local.setUint16(p, 0, true); p+=2;
    local.setUint16(p, 0, true); p+=2;
    local.setUint32(p, c, true); p+=4;
    local.setUint32(p, data.length, true); p+=4;
    local.setUint32(p, data.length, true); p+=4;
    local.setUint16(p, nameBytes.length, true); p+=2;
    local.setUint16(p, 0, true); p+=2;

    chunks.push(new Uint8Array(local.buffer));
    chunks.push(nameBytes);
    chunks.push(data);

    fileRecords.push({ nameBytes, c, size: data.length, offset });
    offset += 30 + nameBytes.length + data.length;
  }

  const cdChunks = [];
  let cdSize = 0;
  for (const rec of fileRecords) {
    const cd = new DataView(new ArrayBuffer(46));
    let p=0;
    cd.setUint32(p, 0x02014b50, true); p+=4;
    cd.setUint16(p, 20, true); p+=2;
    cd.setUint16(p, 20, true); p+=2;
    cd.setUint16(p, 0, true); p+=2;
    cd.setUint16(p, 0, true); p+=2;
    cd.setUint16(p, 0, true); p+=2;
    cd.setUint16(p, 0, true); p+=2;
    cd.setUint32(p, rec.c, true); p+=4;
    cd.setUint32(p, rec.size, true); p+=4;
    cd.setUint32(p, rec.size, true); p+=4;
    cd.setUint16(p, rec.nameBytes.length, true); p+=2;
    cd.setUint16(p, 0, true); p+=2;
    cd.setUint16(p, 0, true); p+=2;
    cd.setUint16(p, 0, true); p+=2;
    cd.setUint16(p, 0, true); p+=2;
    cd.setUint32(p, 0, true); p+=4;
    cd.setUint32(p, rec.offset, true); p+=4;

    cdChunks.push(new Uint8Array(cd.buffer));
    cdChunks.push(rec.nameBytes);
    cdSize += 46 + rec.nameBytes.length;
  }

  const end = new DataView(new ArrayBuffer(22));
  let q=0;
  end.setUint32(q, 0x06054b50, true); q+=4;
  end.setUint16(q, 0, true); q+=2;
  end.setUint16(q, 0, true); q+=2;
  end.setUint16(q, fileRecords.length, true); q+=2;
  end.setUint16(q, fileRecords.length, true); q+=2;
  end.setUint32(q, cdSize, true); q+=4;
  end.setUint32(q, offset, true); q+=4;
  end.setUint16(q, 0, true); q+=2;

  const blob = new Blob([...chunks, ...cdChunks, new Uint8Array(end.buffer)], { type: 'application/zip' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'photos.zip';
  a.click();
  URL.revokeObjectURL(url);
}

document.getElementById('exportBtn').addEventListener('click', exportZip);

document.getElementById('clearBtn').addEventListener('click', async () => {
  if (confirm('Remove all photos from this device?')) {
    await idbClear(db, STORE);
    await refreshGallery();
  }
});
</script>
</body>
</html>
