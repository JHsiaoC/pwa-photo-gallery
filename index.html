<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="robots" content="noindex, nofollow" />
  <title>My Photo Album</title>
  <meta name="theme-color" content="#0F172A" />
  <link rel="manifest" href="manifest.webmanifest">
  <link rel="icon" href="icons/icon-192.png">
  <style>
    :root { --bg:#0b1220; --card:#0f172a; --muted:#94a3b8; --text:#e2e8f0; --accent:#38bdf8; }
    * { box-sizing: border-box; }
    body { margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; background: var(--bg); color: var(--text); }
    header { position: sticky; top: 0; z-index: 10; backdrop-filter: saturate(180%) blur(6px); background: rgba(15,23,42,.85); border-bottom: 1px solid rgba(148,163,184,.15); }
    .wrap { max-width: 1100px; margin: 0 auto; padding: 12px 16px; }
    .row { display: flex; gap: 12px; align-items: center; }
    h1 { font-size: 18px; margin: 0; letter-spacing: .2px; }
    .spacer { flex: 1; }
    button, label.btn { cursor: pointer; border: 1px solid rgba(148,163,184,.25); background: linear-gradient(180deg, #1e293b, #0f172a); color: var(--text); padding: 8px 12px; border-radius: 12px; font-weight: 600; }
    button:hover, label.btn:hover { border-color: rgba(148,163,184,.45); }
    input[type=file] { display: none; }

    .toolbar { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(180px,1fr)); gap: 10px; padding: 16px; }
    .card { position: relative; border-radius: 14px; overflow: hidden; background: var(--card); border: 1px solid rgba(148,163,184,.15); box-shadow: 0 6px 20px rgba(0,0,0,.25); }
    .card img { display: block; width: 100%; height: 180px; object-fit: cover; background: #111827; }
    .meta { display:flex; align-items:center; justify-content: space-between; gap:8px; padding: 8px 10px; font-size: 12px; color: var(--muted); }
    .chip { padding: 3px 8px; border-radius: 999px; background: rgba(56,189,248,.12); color: var(--text); border:1px solid rgba(56,189,248,.35); font-weight:600; }
    .empty { text-align:center; color: var(--muted); padding: 60px 16px; }

    .dropzone { border:2px dashed rgba(148,163,184,.35); border-radius:16px; padding:16px; text-align:center; color: var(--muted); }
    .dropzone.drag { border-color: var(--accent); background: rgba(56,189,248,.06); color: var(--text); }

    .footer { text-align:center; color: var(--muted); padding: 24px; }
    .hidden { display:none; }
  </style>
</head>
<body>
<header>
  <div class="wrap row">
    <h1>ðŸ“¸ My Photo Album</h1>
    <div class="spacer"></div>
    <div class="toolbar">
      <label class="btn" for="fileInput">Add Photos</label>
      <input id="fileInput" type="file" accept="image/*" multiple>
      <button id="installBtn" class="hidden">Install</button>
      <button id="exportBtn">Export (.zip)</button>
      <button id="clearBtn" title="Remove all photos">Clear</button>
    </div>
  </div>
</header>

<main class="wrap">
  <div id="dropzone" class="dropzone">Drag & drop images here or use <strong>Add Photos</strong></div>
  <section id="gallery" class="grid" aria-live="polite"></section>
  <p id="emptyState" class="empty">No photos yet. Add some!
    <br>Everything stays on this device (IndexedDB). Works offline.
  </p>
</main>

<p class="footer">PWA â€¢ Offline â€¢ Installable â€¢ Clientâ€‘side storage</p>

<script>
/**
 * --- CONFIG ---
 * Set the base path for GitHub Pages. If your site is at https://user.github.io/repo/, use "/repo/".
 * If it's a user/org root (https://user.github.io/), use "/".
 */
const basePath = "/pwa-photo-gallery/";

// Register service worker
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register(basePath + 'sw.js').catch(console.error);
  });
}

// Install prompt UX
let deferredPrompt;
const installBtn = document.getElementById('installBtn');
window.addEventListener('beforeinstallprompt', (e) => {
  e.preventDefault();
  deferredPrompt = e;
  installBtn.classList.remove('hidden');
});
installBtn?.addEventListener('click', async () => {
  if (!deferredPrompt) return;
  deferredPrompt.prompt();
  await deferredPrompt.userChoice; // result.outcome
  deferredPrompt = null;
  installBtn.classList.add('hidden');
});

// --- Tiny IndexedDB helper ---
function idbOpen(dbName, storeName) {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(dbName, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(storeName)) {
        const s = db.createObjectStore(storeName, { keyPath: 'id', autoIncrement: true });
        s.createIndex('created', 'created');
      }
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}
function idbAdd(db, store, value) {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(store, 'readwrite');
    tx.objectStore(store).add(value);
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
}
function idbAll(db, store) {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(store, 'readonly');
    const req = tx.objectStore(store).getAll();
    req.onsuccess = () => resolve(req.result || []);
    req.onerror = () => reject(req.error);
  });
}
function idbClear(db, store) {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(store, 'readwrite');
    tx.objectStore(store).clear();
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
}

const DB_NAME = 'pwa-photo-album';
const STORE = 'photos';
let db;

(async () => { db = await idbOpen(DB_NAME, STORE); await refreshGallery(); })();

// File input & drag-drop
const input = document.getElementById('fileInput');
const dz = document.getElementById('dropzone');

input.addEventListener('change', async (e) => {
  await addFiles(e.target.files);
  input.value = '';
});

;['dragenter','dragover'].forEach(evt => dz.addEventListener(evt, (e)=>{ e.preventDefault(); dz.classList.add('drag'); }));
;['dragleave','drop'].forEach(evt => dz.addEventListener(evt, (e)=>{ e.preventDefault(); dz.classList.remove('drag'); }));

dz.addEventListener('drop', async (e) => {
  const files = e.dataTransfer.files;
  await addFiles(files);
});

async function addFiles(fileList) {
  if (!fileList || !fileList.length) return;
  const arr = Array.from(fileList).filter(f => f.type.startsWith('image/'));
  for (const file of arr) {
    const arrayBuf = await file.arrayBuffer();
    const blob = new Blob([arrayBuf], { type: file.type || 'image/jpeg' });
    const created = Date.now();
    const url = URL.createObjectURL(blob);
    const { width, height } = await imgSize(url);
    URL.revokeObjectURL(url);
    await idbAdd(db, STORE, { blob, name: file.name || 'photo', type: file.type, created, width, height });
  }
  await refreshGallery();
}

function imgSize(url) {
  return new Promise((res, rej) => { const i = new Image(); i.onload = ()=>res({width:i.naturalWidth, height:i.naturalHeight}); i.onerror=rej; i.src=url; });
}

async function refreshGallery() {
  const list = await idbAll(db, STORE);
  list.sort((a,b)=>b.created-a.created);
  const g = document.getElementById('gallery');
  const empty = document.getElementById('emptyState');
  g.innerHTML = '';
  if (!list.length) { empty.classList.remove('hidden'); return; }
  empty.classList.add('hidden');

  for (const it of list) {
    const url = URL.createObjectURL(it.blob);
    const card = document.createElement('div');
    card.className = 'card';

    const img = document.createElement('img');
    img.loading = 'lazy';
    img.alt = it.name;
    img.src = url;
    card.appendChild(img);

    const meta = document.createElement('div');
    meta.className = 'meta';
    const label = document.createElement('span');
    label.textContent = new Date(it.created).toLocaleString();
    const chip = document.createElement('span');
    chip.className = 'chip';
    chip.textContent = `${it.width}Ã—${it.height}`;
    meta.append(label, chip);
    card.appendChild(meta);

    card.addEventListener('click', () => viewPhoto(it));

    g.appendChild(card);
  }
}

// Simple viewer
function viewPhoto(item) {
  const w = window.open('', '_blank');
  const url = URL.createObjectURL(item.blob);
  const html = `<!doctype html><title>${item.name}</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>body{margin:0;background:#0b1220;color:#e2e8f0;display:grid;place-items:center}img{max-width:100vw;max-height:100vh;object-fit:contain;background:#111827}</style>
  <img src="${url}" alt="${item.name}">`;
  w.document.write(html);
  w.document.close();
}

// Export all photos as a .zip (no server)
// A tiny zip writer (Store only) to avoid dependencies
async function exportZip() {
  const files = await idbAll(db, STORE);
  if (!files.length) return alert('No photos to export.');
  // Minimal ZIP: store only, no compression. For many photos this is fine.
  // If you need compression, swap this for a library like JSZip.
  const encoder = new TextEncoder();
  const fileRecords = [];
  let offset = 0;
  const chunks = [];

  function crc32(buf) {
    // small CRC32 implementation
    const table = (function(){
      let c, table = new Uint32Array(256);
      for (let n=0; n<256; n++) { c=n; for (let k=0;k<8;k++) c = (c&1)?(0xEDB88320^(c>>>1)):(c>>>1); table[n]=c>>>0; }
      return table;
    })();
    let crc = 0 ^ (-1);
    for (let i=0; i<buf.length; i++) crc = (crc>>>8) ^ table[(crc ^ buf[i]) & 0xFF];
    return (crc ^ (-1)) >>> 0;
  }

  for (const f of files) {
    const name = (f.name || 'photo').replace(/\//g, '_');
    const nameBytes = encoder.encode(name);
    const data = new Uint8Array(await f.blob.arrayBuffer());
    const c = crc32(data);

    // Local file header
    const local = new DataView(new ArrayBuffer(30));
    let p=0;
    local.setUint32(p, 0x04034b50, true); p+=4; // signature
    local.setUint16(p, 20, true); p+=2; // version needed
    local.setUint16(p, 0, true); p+=2; // general flag
    local.setUint16(p, 0, true); p+=2; // method: store
    local.setUint16(p, 0, true); p+=2; // mod time (0)
    local.setUint16(p, 0, true); p+=2; // mod date (0)
    local.setUint32(p, c, true); p+=4; // crc32
    local.setUint32(p, data.length, true); p+=4; // comp size
    local.setUint32(p, data.length, true); p+=4; // uncomp size
    local.setUint16(p, nameBytes.length, true); p+=2; // name len
    local.setUint16(p, 0, true); p+=2; // extra len

    chunks.push(new Uint8Array(local.buffer));
    chunks.push(nameBytes);
    chunks.push(data);

    fileRecords.push({ nameBytes, c, size: data.length, offset });
    offset += 30 + nameBytes.length + data.length;
  }

  const cdChunks = [];
  let cdSize = 0;
  for (const rec of fileRecords) {
    const cd = new DataView(new ArrayBuffer(46));
    let p=0;
    cd.setUint32(p, 0x02014b50, true); p+=4; // signature
    cd.setUint16(p, 20, true); p+=2; // version made by
    cd.setUint16(p, 20, true); p+=2; // version needed
    cd.setUint16(p, 0, true); p+=2; // flag
    cd.setUint16(p, 0, true); p+=2; // method
    cd.setUint16(p, 0, true); p+=2; // time
    cd.setUint16(p, 0, true); p+=2; // date
    cd.setUint32(p, rec.c, true); p+=4; // crc
    cd.setUint32(p, rec.size, true); p+=4; // comp size
    cd.setUint32(p, rec.size, true); p+=4; // uncomp size
    cd.setUint16(p, rec.nameBytes.length, true); p+=2; // name len
    cd.setUint16(p, 0, true); p+=2; // extra len
    cd.setUint16(p, 0, true); p+=2; // comment len
    cd.setUint16(p, 0, true); p+=2; // disk start
    cd.setUint16(p, 0, true); p+=2; // int attrs
    cd.setUint32(p, 0, true); p+=4; // ext attrs
    cd.setUint32(p, rec.offset, true); p+=4; // local header offset

    cdChunks.push(new Uint8Array(cd.buffer));
    cdChunks.push(rec.nameBytes);
    cdSize += 46 + rec.nameBytes.length;
  }

  const end = new DataView(new ArrayBuffer(22));
  let q=0;
  end.setUint32(q, 0x06054b50, true); q+=4; // signature
  end.setUint16(q, 0, true); q+=2; // disk
  end.setUint16(q, 0, true); q+=2; // start disk
  end.setUint16(q, fileRecords.length, true); q+=2; // # on this disk
  end.setUint16(q, fileRecords.length, true); q+=2; // total #
  end.setUint32(q, cdSize, true); q+=4; // size of central dir
  end.setUint32(q, offset, true); q+=4; // offset of central dir
  end.setUint16(q, 0, true); q+=2; // comment len

  const blob = new Blob([...chunks, ...cdChunks, new Uint8Array(end.buffer)], { type: 'application/zip' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'photos.zip';
  a.click();
  URL.revokeObjectURL(url);
}

document.getElementById('exportBtn').addEventListener('click', exportZip);

document.getElementById('clearBtn').addEventListener('click', async () => {
  if (confirm('Remove all photos from this device?')) {
    await idbClear(db, STORE);
    await refreshGallery();
  }
});
</script>
</body>
</html>
