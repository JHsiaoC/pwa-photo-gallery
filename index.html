<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="robots" content="noindex, nofollow" />
  <title>My Photo Album</title>
  <meta name="theme-color" content="#0F172A" />
  <link rel="manifest" href="manifest.webmanifest">
  <link rel="icon" href="icons/icon-192.png">
  <!-- MARK:styles -->
  <style>
    :root {
      --bg:#050812;
      --card:#0f172a;
      --muted:#94a3b8;
      --text:#f1f5f9;
      --accent:#38bdf8;
      --accent-strong:#0ea5e9;
      --sidebar:#0b1220;
      --icon-filter: invert(1) brightness(1.6);
    }
    * { box-sizing: border-box; }
    :root {
      --bg-pattern: radial-gradient(circle at top, rgba(56,189,248,.25), transparent 45%);
    }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: var(--bg-pattern), var(--bg);
      color: var(--text);
      min-height: 100vh;
    }
    header {
      position: sticky;
      top: 0;
      z-index: 20;
      backdrop-filter: saturate(180%) blur(10px);
      background: rgba(5,8,18,.9);
      border-bottom: 1px solid rgba(148,163,184,.15);
    }
    .wrap { max-width: 1200px; margin: 0 auto; padding: 12px 16px; }
    .row { display: flex; gap: 12px; align-items: center; }
    h1 { font-size: 18px; margin: 0; letter-spacing: .2px; }
    .spacer { flex: 1; }
    button, label.btn {
      cursor: pointer;
      border: 1px solid rgba(148,163,184,.25);
      background: linear-gradient(180deg, #1e293b, #0f172a);
      color: var(--text);
      padding: 8px 12px;
      border-radius: 12px;
      font-weight: 600;
      transition: border-color .2s ease, transform .2s ease;
    }
    button:hover, label.btn:hover { border-color: rgba(148,163,184,.45); }
    button:active { transform: scale(.98); }
    input[type=file] { display: none; }
    .app-shell { display: flex; gap: 24px; width: 100%; margin: 0; padding: 0 16px 120px; }
    .sidebar { display: none; }
    .brand-card { display: flex; align-items: center; gap: 12px; }
    .brand-card .emoji {
      width: 48px;
      height: 48px;
      border-radius: 16px;
      background: rgba(56,189,248,.15);
      display: grid;
      place-items: center;
      font-size: 20px;
    }
    .brand-card strong { display:block; font-size: 16px; }
    .brand-card span { color: var(--muted); font-size: 12px; }
    .sidebar-section { display:flex; flex-direction:column; gap:10px; }
    .sidebar-section.hidden { display:none; }
    .section-header { display:flex; justify-content:space-between; align-items:center; font-size:12px; text-transform:uppercase; letter-spacing:.08em; color:var(--muted); }
    .section-header button { padding:6px 10px; border-radius:999px; }
    .folder-list,
    .album-list { display: flex; flex-direction: column; gap: 8px; max-height: calc(100vh - 260px); overflow-y: auto; }
    .album-item {
      display: flex;
      align-items: center;
      gap: 12px;
      width: 100%;
      background: rgba(15,23,42,.75);
      border-radius: 16px;
      padding: 10px 12px;
      border: 1px solid transparent;
      text-align: left;
    }
    .album-item .album-icon { font-size: 18px; }
    .album-meta { display: flex; flex-direction: column; font-size: 11px; color: var(--muted); }
    .album-meta strong { font-size: 14px; color: var(--text); }
    .album-item.active { border-color: var(--accent); background: rgba(56,189,248,.12); }

    .workspace {
      flex: 1;
      min-height: calc(100vh - 140px);
      padding: 24px max(8px, 3vw) 140px;
      width: 100%;
    }
    .album-heading { display:none; }
    .eyebrow { margin:0; font-size:11px; text-transform:uppercase; letter-spacing:.2em; color:var(--muted); text-align:center; }
    #activeAlbumTitle { margin:4px 0 0; font-size: 28px; text-align:center; }
    .controls-stack { display:flex; flex-direction:column; gap:8px; align-items:flex-start; }
    .control-row { display:flex; flex-wrap:wrap; gap:12px; align-items:center; font-size:12px; color:var(--muted); }
    .control-row.hidden { display:none; }
    .sort-toolbar {
      display:flex;
      gap:12px;
      align-items:flex-end;
      flex-wrap:wrap;
      font-size:12px;
      color:var(--muted);
    }
    .sort-toolbar select {
      background: rgba(15,23,42,.85);
      color: var(--text);
      border: 1px solid rgba(148,163,184,.25);
      border-radius: 12px;
      padding: 6px 10px;
      font-weight:600;
    }
    .sort-toolbar button {
      padding:6px 10px;
      border-radius:12px;
    }
    .drive-shell { background: transparent; border-radius: 0; border: none; box-shadow: none; padding: 12px 0 40px; min-height: 60vh; }
    .drive-header { display:grid; grid-template-columns:auto 1fr auto; align-items:center; gap:16px; margin-bottom:12px; }
    .drive-heading { text-align:center; }
    .drive-back-btn { width:40px; height:40px; border-radius:20px; border:1px solid rgba(148,163,184,.25); background: rgba(15,23,42,.9); color:var(--text); font-size:18px; cursor:pointer; display:flex; align-items:center; justify-content:center; }
    .drive-back-btn img { width:26px; height:26px; filter:var(--icon-filter); }
    .drive-back-btn.hidden { visibility:hidden; }
    .drive-actions { display:flex; gap:12px; justify-content:flex-end; align-items:center; }
    .action-btn { width:40px; height:40px; border-radius:20px; border:1px solid rgba(148,163,184,.25); background: rgba(15,23,42,.9); color:var(--text); font-size:20px; cursor:pointer; display:flex; align-items:center; justify-content:center; line-height:1; letter-spacing:1px; }
    .action-btn img,
    .icon-btn img,
    .inline-icon,
    .circle-check img,
    .search-bar .search-icon,
    .tab-icon img {
      width:18px;
      height:18px;
      object-fit:contain;
      display:inline-block;
      vertical-align:middle;
      pointer-events:none;
      filter: var(--icon-filter);
    }
    .tab-icon {
      width:20px;
      height:20px;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .menu-icon { width:18px; height:18px; margin-right:8px; display:inline-flex; }
    .list-icon { width:20px; height:20px; margin-right:10px; display:inline-flex; align-items:center; justify-content:center; }
    .list-icon img { width:100%; height:100%; object-fit:contain; }
    .search-bar .search-icon { position:absolute; top:50%; left:14px; transform:translateY(-50%); width:18px; height:18px; object-fit:contain; }
    .ellipsis-icon { font-size:16px; letter-spacing:2px; white-space:nowrap; display:inline-block; transform:translateY(-1px); }
    .circle-check {
      width:22px;
      height:22px;
      border-radius:50%;
      border:1.5px solid rgba(148,163,184,.7);
      display:inline-flex;
      align-items:center;
      justify-content:center;
      margin-right:8px;
    }
    .circle-check img { width:14px; height:14px; object-fit:contain; }
    .dropdown { position:relative; }
    .dropdown-menu { position:absolute; top:48px; right:0; background:rgba(11,17,31,.95); border:1px solid rgba(148,163,184,.2); border-radius:16px; min-width:220px; padding:8px 0; box-shadow:0 12px 30px rgba(0,0,0,.5); z-index:20; display:none; }
    .dropdown-menu.show { display:block; }
    .dropdown-menu button { width:100%; background:none; border:none; color:var(--text); padding:10px 16px; text-align:left; font-size:14px; display:flex; align-items:center; gap:10px; cursor:pointer; }
    .dropdown-menu button:hover { background:rgba(56,189,248,.1); }
    .dropdown-divider { height:1px; background:rgba(148,163,184,.2); margin:6px 0; }
    .search-bar { margin:8px 0 18px; position:relative; }
    .search-bar input { width:100%; padding:12px 16px 12px 40px; border-radius:16px; border:1px solid rgba(148,163,184,.25); background:rgba(15,23,42,.85); color:var(--text); font-size:14px; }
    .drive-section { margin-top:20px; }
    .drive-section h3 { margin:0 0 12px; font-size:16px; color:var(--muted); text-transform:uppercase; letter-spacing:.2em; }
    .folder-grid { display:grid; grid-template-columns: repeat(auto-fill, minmax(240px,1fr)); gap:12px; }
    @media (max-width: 600px) {
      .folder-grid { grid-template-columns: repeat(2, minmax(0,1fr)); }
    }
    .folder-card {
      position:relative;
      background:rgba(15,23,42,.8);
      border:1px solid rgba(148,163,184,.2);
      padding:14px;
      border-radius:24px;
      min-height:0;
      aspect-ratio:1;
      display:flex;
      flex-direction:column;
      justify-content:flex-start;
      gap:4px;
      cursor:pointer;
      overflow:hidden;
    }
    .folder-icon-wrap {
      width:100%;
      height:130px;
      border-radius:16px;
      background:rgba(59,130,246,.08);
      display:flex;
      align-items:center;
      justify-content:center;
      margin-bottom:4px;
    }
    .folder-icon-wrap img { width:80px; height:80px; object-fit:contain; filter:none; }
    .folder-card.active { border-color: var(--accent); }
    .folder-card .name { font-weight:600; font-size:16px; }
    .folder-card .count { font-size:12px; color:var(--muted); }
    .drive-contents { margin-top:24px; }
    .folder-list-view { display:flex; flex-direction:column; gap:10px; }
    .folder-list-view .folder-card {
      flex-direction:row;
      align-items:center;
      min-height:60px;
      padding:10px 16px;
      gap:12px;
      aspect-ratio:auto;
    }
    .folder-list-view .folder-card .name { font-size:15px; }
    .folder-list-view .folder-card .count { font-size:12px; }
    .folder-list-view .folder-card .select-indicator { position:static; order: -1; }
    .media-card { justify-content:flex-start; gap:6px; }
    .media-card .thumb { width:100%; height:150px; border-radius:16px; background:#020617; overflow:hidden; display:flex; align-items:center; justify-content:center; margin-bottom:8px; }
    .media-card img,
    .media-card video { width:100%; height:100%; object-fit:cover; border-radius:inherit; }
    .media-card video { pointer-events:none; }
    .media-card .name { font-size:15px; margin:0; }
    .media-card .meta { padding:0; width:100%; margin-top:4px; }
    .media-card .chip { margin-left:auto; }
    .media-card .thumb .text-card { height:100%; border-radius:inherit; padding:16px; line-height:1.4; color:var(--muted); }
    .folder-list-view .media-card { flex-direction:row; align-items:center; }
    .folder-list-view .media-card .thumb { width:140px; height:90px; margin:0 16px 0 0; }
    .folder-list-view .media-card .meta { flex-direction:column; align-items:flex-start; gap:4px; }
    .grid.list-view { display:flex; flex-direction:column; }
    .grid.list-view .card { display:flex; gap:16px; height:auto; }
    .grid.list-view .card img, .grid.list-view .card video { width:140px; height:90px; border-radius:16px; }
    .grid.list-view .text-card { width:140px; height:90px; }
    .grid.list-view .text-card { width:140px; height:90px; }
    .bottom-tabs { position:fixed; bottom:16px; left:50%; transform:translateX(-50%); background:rgba(11,17,31,.9); border:1px solid rgba(148,163,184,.2); border-radius:999px; padding:10px 18px; display:flex; gap:16px; z-index:30; box-shadow:0 10px 40px rgba(0,0,0,.5); align-items:center; }
    .bottom-tabs .tab-buttons,
    .bottom-tabs .selection-actions { display:flex; gap:12px; align-items:center; }
    .bottom-tabs .selection-actions.hidden { display:none; }
    .selection-group { display:flex; gap:12px; align-items:center; }
    .selection-group.hidden { display:none; }
    .bottom-tabs button { background:none; border:none; color:var(--muted); font-weight:600; padding:6px 14px; border-radius:999px; cursor:pointer; transition:background .2s ease, color .2s ease; display:flex; flex-direction:column; align-items:center; gap:6px; }
    .bottom-tabs button.active { background:rgba(56,189,248,.12); color:var(--text); }
    .bottom-tabs .selection-actions button { color:var(--text); border:none; background:none; padding:0; }
    .bottom-tabs .selection-actions button:disabled { opacity:.4; cursor:not-allowed; }
    .bottom-tabs.action-mode .tab-buttons { display:none; }
    .bottom-tabs.action-mode .selection-actions { display:flex; }
    .select-indicator {
      width:22px;
      height:22px;
      border-radius:50%;
      border:2px solid rgba(148,163,184,.5);
      background:rgba(15,23,42,.85);
      display:flex;
      align-items:center;
      justify-content:center;
      flex:0 0 22px;
      opacity:0;
      transition:opacity .2s ease, background .2s ease, border-color .2s ease;
    }
    .select-indicator::after {
      content:'';
      width:8px;
      height:4px;
      border-left:2px solid transparent;
      border-bottom:2px solid transparent;
      transform:rotate(-45deg);
      opacity:0;
      transition:opacity .2s ease, border-color .2s ease;
    }
    .selected .select-indicator {
      background:#22c55e;
      border-color:#22c55e;
    }
    .selected .select-indicator::after {
      border-color:#fff;
      opacity:1;
    }
    .folder-card .select-indicator,
    .album-media-card .select-indicator,
    .album-card .select-indicator {
      position:absolute;
      top:10px;
      right:10px;
    }
    .folder-list-view .folder-card .select-indicator {
      position:static;
      order:-1;
      margin-right:12px;
      flex:0 0 22px;
    }
    .drive-shell .select-indicator,
    .album-shell .select-indicator,
    .album-media-panel .select-indicator {
      transition:opacity .2s ease;
    }
    .drive-shell.selecting .select-indicator,
    .album-shell.album-selecting .select-indicator,
    .album-media-panel.selecting .select-indicator {
      opacity:1;
    }
    .album-media-panel { margin-top:20px; position:relative; }
    .album-media-panel .grid { gap:2px; }
    .album-media-panel .album-media-card {
      border-radius:0;
      box-shadow:none;
      border:none;
    }
    .album-media-panel .album-media-card .meta {
      display:none;
    }
    .album-shell,
    .settings-shell { background: transparent; border-radius: 0; border:none; box-shadow:none; padding: 24px 0 40px; min-height: 60vh; }
    .photos-header { margin-bottom:16px; }
    #photosHeading { margin:0; font-size:28px; }
    .album-toolbar { display:flex; align-items:center; gap:12px; margin-bottom:16px; }
    .album-toolbar .photos-header { flex:1; margin-bottom:0; text-align:left; }
    .settings-shell .photos-header { text-align:center; }
    .album-toolbar .album-actions { display:flex; gap:12px; }
    .album-grid { display:grid; grid-template-columns: repeat(auto-fill, minmax(240px,1fr)); gap:18px; }
    @media (max-width: 600px) {
      .album-grid { grid-template-columns: repeat(3, minmax(0,1fr)); }
    }
    .album-grid.list-view { display:flex; flex-direction:column; gap:12px; }
    .album-grid:not(.list-view) { gap:18px; }
    .album-card {
      border:none;
      background:transparent;
      padding:0;
      display:flex;
      flex-direction:column;
      gap:8px;
      align-items:center;
      justify-content:flex-start;
      text-align:center;
      min-height:0;
      position:relative;
    }
    .album-card-thumb {
      width:100%;
      aspect-ratio:1 / 1;
      border-radius:26px;
      overflow:hidden;
      background:rgba(2,6,23,.85);
      display:flex;
      align-items:center;
      justify-content:center;
      position:relative;
      border:1px solid rgba(148,163,184,.2);
      box-shadow: 0 15px 40px rgba(0,0,0,.35);
    }
    .album-card-thumb img,
    .album-card-thumb video {
      width:100%;
      height:100%;
      object-fit:cover;
      display:block;
    }
    .album-card-thumb video { pointer-events:none; }
    .album-card-thumb .thumb-placeholder {
      width:42px;
      height:42px;
      object-fit:contain;
      opacity:.75;
      filter:var(--icon-filter);
    }
    .album-thumb-text {
      width:100%;
      height:100%;
      padding:12px;
      font-size:13px;
      color:var(--muted);
      text-align:left;
      background:rgba(2,6,23,.9);
      overflow:hidden;
      white-space:pre-wrap;
    }
    .album-card-body {
      display:flex;
      flex-direction:column;
      gap:4px;
      align-items:flex-start;
      padding:0 4px;
      width:100%;
    }
    .album-card .title,
    .album-card .count {
      text-align:left;
      width:100%;
      color:var(--text);
    }
    .album-card.new {
      border:1px dashed rgba(148,163,184,.4);
      color:var(--muted);
      justify-content:center;
      align-items:center;
      gap:10px;
    }
    .album-card .album-new-icon {
      font-size:32px;
      display:flex;
      align-items:center;
      justify-content:center;
      width:48px;
      height:48px;
    }
    .album-card.active .album-card-thumb,
    .album-card.selected .album-card-thumb {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(56,189,248,.45);
    }
    .album-grid.list-view .album-card {
      flex-direction:row;
      aspect-ratio:auto;
      gap:16px;
      padding:18px 20px;
      justify-content:flex-start;
      align-items:center;
      text-align:left;
      overflow:visible;
    }
    .album-grid.list-view .album-card-thumb {
      width:120px;
      height:90px;
      aspect-ratio:auto;
      border-radius:18px;
      max-height:none;
      flex:0 0 auto;
    }
    .album-grid.list-view .album-card-body { align-items:flex-start; }
    .album-grid.list-view .album-card .count { text-align:left; }
    .album-grid:not(.list-view) .album-card {
      border-radius:24px;
      padding:0 0 12px;
      gap:8px;
      box-shadow:none;
      border:none;
    }
    .album-grid:not(.list-view) .album-card-thumb {
      border-radius:24px;
      max-height:none;
      flex:auto;
    }
    .album-empty { text-align:center; padding:24px; color:var(--muted); }
    .theme-grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(200px,1fr)); gap:16px; }
    .theme-card { border-radius:20px; border:1px solid rgba(148,163,184,.2); padding:18px; background:rgba(15,23,42,.85); display:flex; flex-direction:column; gap:12px; cursor:pointer; transition:border-color .2s ease, box-shadow .2s ease, transform .2s ease; }
    .theme-card.active { border-color: var(--accent); box-shadow:0 0 0 2px rgba(56,189,248,.3); transform:translateY(-2px); }
    .theme-preview { border-radius:14px; height:90px; background:#1e293b; position:relative; overflow:hidden; }
    .theme-preview span { position:absolute; inset:0; opacity:.4; border-radius:inherit; }
    .theme-meta strong { font-size:16px; }

    .grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(180px,1fr)); gap: 12px; margin-top: 18px; }
    .card { position: relative; border-radius: 16px; overflow: hidden; background: var(--card); border: 1px solid rgba(148,163,184,.15); box-shadow: 0 6px 20px rgba(0,0,0,.25); }
    .card img, .card video { display: block; width: 100%; height: 200px; object-fit: cover; background: #111827; }
    .card video { pointer-events: none; }
    .album-media-card { border:none; background:transparent; padding:0; color:var(--text); text-align:left; display:block; width:100%; }
    .album-media-card .meta { border-top:1px solid rgba(148,163,184,.2); }
    .media-flag {
      position:absolute;
      top:8px;
      right:8px;
      background:rgba(5,8,18,.75);
      border-radius:999px;
      padding:4px 8px;
      font-size:12px;
      display:flex;
      align-items:center;
      gap:4px;
    }
    .meta { display:flex; align-items:center; justify-content: space-between; gap:8px; padding: 8px 10px; font-size: 12px; color: var(--muted); }
    .chip { padding: 3px 8px; border-radius: 999px; background: rgba(56,189,248,.12); color: var(--text); border:1px solid rgba(56,189,248,.35); font-weight:600; }
    .text-card {
      width: 100%;
      height: 200px;
      border-radius: 16px;
      background: rgba(15,23,42,.85);
      color: var(--muted);
      padding: 16px;
      overflow: hidden;
      display:flex;
      align-items:flex-start;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 13px;
      white-space: pre-wrap;
    }
    .empty { text-align:center; color: var(--muted); padding: 60px 16px; border: 1px dashed rgba(148,163,184,.25); border-radius: 18px; margin-top: 24px; }
    .empty strong { color: var(--text); }


    .footer { text-align:center; color: var(--muted); padding: 24px; }
    .hidden { display:none !important; }

    .modal {
      position: fixed;
      inset: 0;
      background: rgba(5,8,18,.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 80;
    }
    .modal-card {
      background: var(--sidebar);
      border-radius: 20px;
      padding: 24px;
      width: min(360px, 90vw);
      border: 1px solid rgba(148,163,184,.2);
      box-shadow: 0 20px 60px rgba(0,0,0,.45);
    }
    .modal-card h3 { margin-top:0; margin-bottom:12px; }
    .modal-card label { display:block; font-size:13px; color:var(--muted); margin-bottom:4px; }
    .modal-card input {
      width: 100%;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(148,163,184,.3);
      background: rgba(15,23,42,.9);
      color: var(--text);
      font-size: 14px;
    }
    .modal-actions { display:flex; justify-content:flex-end; gap:8px; margin-top:18px; }
    #listPickerModal .modal-card { width:min(520px, 95vw); }
    .picker-list {
      display:grid;
      grid-template-columns:repeat(auto-fit, minmax(140px, 1fr));
      gap:12px;
      max-height:60vh;
      overflow-y:auto;
      margin-top:12px;
      padding-right:4px;
    }
    .picker-card {
      width:100%;
      text-align:left;
      padding:10px;
      border-radius:16px;
      border:1px solid rgba(148,163,184,.2);
      background:rgba(15,23,42,.9);
      color:var(--text);
      font-weight:600;
      display:flex;
      flex-direction:column;
      gap:8px;
      transition:border-color .2s ease;
    }
    .picker-card:hover { border-color:var(--accent); }
    .picker-thumb {
      width:100%;
      aspect-ratio:1 / 1;
      border-radius:14px;
      background:rgba(2,6,23,.85);
      overflow:hidden;
      display:flex;
      align-items:center;
      justify-content:center;
      position:relative;
    }
    .picker-thumb img,
    .picker-thumb video {
      width:100%;
      height:100%;
      object-fit:cover;
      display:block;
    }
    .picker-thumb video {
      pointer-events:none;
    }
    .picker-thumb-icon {
      width:36px;
      height:36px;
      object-fit:contain;
      opacity:.8;
      filter:var(--icon-filter);
    }
    .picker-thumb-text {
      width:100%;
      height:100%;
      padding:12px;
      font-size:12px;
      color:var(--muted);
      text-align:left;
      overflow:hidden;
      white-space:pre-wrap;
    }
    .picker-label { font-size:14px; font-weight:600; }
    .picker-subtitle { font-size:12px; color:var(--muted); }
    .picker-list .empty { grid-column:1 / -1; margin:0; }

    @media (max-width: 960px) {
      .app-shell { flex-direction: column; }
      .sidebar { width: 100%; flex-direction: row; flex-wrap: wrap; }
      .folder-list,
      .album-list { flex-direction: row; flex-wrap: wrap; max-height: none; }
      .album-item { flex: 1 1 160px; }
    }

    .photo-viewer {
      position: fixed;
      inset: 0;
      background: rgba(3,6,15,.95);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 60;
      padding: 0;
      backdrop-filter: blur(6px);
    }
    .photo-viewer .viewer-frame {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      background: transparent;
      border: none;
      padding: 0;
    }
    .viewer-top {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      padding: 16px 16px 0;
      color: var(--text);
      text-shadow: 0 1px 3px rgba(0,0,0,.6);
    }
    .viewer-top-info {
      display: flex;
      flex-direction: column;
      gap: 4px;
      font-size: 13px;
    }
    .viewer-top-info strong {
      font-size: 16px;
    }
    .viewer-top-info span {
      color: var(--muted);
      font-size: 12px;
    }
    .viewer-media {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
      touch-action: none;
    }
    .viewer-media img,
    .viewer-media video {
      width: 100%;
      height: 100%;
      object-fit: contain;
      background: #000;
      transition: transform .2s ease;
    }
    .viewer-media img.zoomed,
    .viewer-media video.zoomed {
      cursor: grab;
    }
    .viewer-actions {
      display: flex;
      justify-content: center;
      gap: 24px;
      padding: 16px;
    }
    .icon-btn {
      background: transparent;
      border: none;
      color: var(--text);
      font-size: 22px;
      padding: 8px;
      border-radius: 50%;
      cursor: pointer;
      transition: opacity .2s ease;
    }
    .icon-btn:hover {
      opacity: .8;
    }
    .photo-viewer.hide-chrome .viewer-top,
    .photo-viewer.hide-chrome .viewer-actions {
      opacity: 0;
      pointer-events: none;
    }
    .photo-viewer.hide-chrome {
      cursor: none;
    }

    .settings-tabs {
      display:flex;
      justify-content:center;
      gap:12px;
      margin:16px 0 24px;
    }
    .settings-tabs button {
      background:rgba(15,23,42,.85);
      border:1px solid rgba(148,163,184,.3);
      color:var(--text);
      padding:8px 16px;
      border-radius:999px;
      font-weight:600;
      cursor:pointer;
      transition:border-color .2s ease, color .2s ease, background .2s ease;
    }
    .settings-tabs button.active {
      border-color:var(--accent);
      background:rgba(56,189,248,.15);
      color:var(--text);
    }
    .settings-panel { max-width:680px; margin:0 auto 32px; }
    .settings-panel.hidden { display:none !important; }
    .settings-panel form {
      width:100%;
      display:flex;
      flex-direction:column;
      gap:12px;
      background:rgba(15,23,42,.85);
      border:1px solid rgba(148,163,184,.2);
      border-radius:18px;
      padding:20px;
    }
    .settings-help {
      font-size:12px;
      color:var(--muted);
      margin-top:8px;
    }
    .settings-preview {
      margin-top:10px;
      padding:10px;
      border-radius:12px;
      background:rgba(15,23,42,.8);
      border:1px solid rgba(148,163,184,.2);
      font-size:13px;
    }
    .token-list { display:flex; flex-wrap:wrap; gap:8px; }
    .token-list button {
      border:1px solid rgba(148,163,184,.3);
      background:transparent;
      color:var(--text);
      padding:4px 10px;
      border-radius:999px;
      font-size:12px;
      cursor:pointer;
    }
    .token-list button:hover { border-color:var(--accent); }
    .settings-actions { display:flex; justify-content:flex-end; gap:8px; }
    .settings-actions button { border-radius:999px; padding:8px 16px; border:1px solid rgba(148,163,184,.3); background:rgba(56,189,248,.15); color:var(--text); font-weight:600; }
    .info-card .info-original { font-size:13px; color:var(--muted); margin:8px 0 14px; }
    .info-grid { display:grid; grid-template-columns:120px 1fr; gap:6px 16px; margin-top:8px; font-size:13px; color:var(--muted); }
    .info-grid dt { font-weight:600; color:var(--text); }
    .info-grid dd { margin:0; }
  </style>
</head>
<body>

<!-- MARK:file-input -->
<input type="file" id="fileInput" accept="image/*,video/*" multiple>

<!-- MARK:app-shell -->
<div class="app-shell">
  <main class="workspace">
    <!-- MARK:drive-shell -->
    <div class="drive-shell">
      <div class="drive-header">
        <button id="driveBackBtn" class="drive-back-btn hidden" type="button" aria-label="Back to parent">
          <img src="icons/left.png" alt="Back">
        </button>
        <div class="drive-heading">
          <h2 id="activeAlbumTitle">Drive</h2>
        </div>
        <div class="drive-actions">
          <div class="dropdown">
            <button class="action-btn" id="primaryAddBtn" aria-haspopup="true" aria-expanded="false" aria-label="Add menu">
              <img src="icons/plus.png" alt="Add">
            </button>
            <div class="dropdown-menu" id="addMenu">
              <button data-add="import"><img src="icons/import.png" alt="" class="inline-icon"> Import Media</button>
              <button data-add="folder"><img src="icons/folder.png" alt="" class="inline-icon"> New Folder</button>
              <button data-add="text"><img src="icons/edit.png" alt="" class="inline-icon"> New Text File</button>
            </div>
          </div>
          <div class="dropdown">
            <button class="action-btn" id="moreActionsBtn" aria-haspopup="true" aria-expanded="false" aria-label="More actions">
              <img src="icons/dots.png" alt="More">
            </button>
            <div class="dropdown-menu" id="moreMenu">
              <button data-action="select"><span class="circle-check"><img src="icons/checkmark.png" alt=""></span>Select</button>
              <div class="dropdown-divider"></div>
              <button data-sort="name-asc"><img src="icons/sort-ascending.png" alt="" class="inline-icon"> Name (ascending)</button>
              <button data-sort="name-desc"><img src="icons/sort-descending.png" alt="" class="inline-icon"> Name (descending)</button>
              <button data-sort="size-desc"><img src="icons/up.png" alt="" class="inline-icon"> Largest</button>
              <button data-sort="size-asc"><img src="icons/down.png" alt="" class="inline-icon"> Smallest</button>
              <button data-sort="created-desc"><img src="icons/newest.png" alt="" class="inline-icon"> Newest</button>
              <button data-sort="created-asc"><img src="icons/oldest.png" alt="" class="inline-icon"> Oldest</button>
              <div class="dropdown-divider"></div>
              <button data-view="list"><img src="icons/list.png" alt="" class="inline-icon"> List View</button>
              <button data-view="grid"><img src="icons/thumbnail.png" alt="" class="inline-icon"> Thumbnail View</button>
            </div>
          </div>
        </div>
      </div>

      <div class="search-bar">
        <img src="icons/search.png" alt="" class="search-icon">
        <input id="driveSearch" type="search" placeholder="Search Drive">
      </div>

      <div class="drive-section drive-contents">
        <div id="driveItems" class="folder-grid" aria-live="polite"></div>
        <p id="emptyState" class="empty">
          No media in <strong id="emptyAlbumLabel">Drive</strong> yet.
        </p>
      </div>
    </div>

    <!-- MARK:album-shell -->
    <div class="album-shell hidden">
      <div class="album-toolbar">
        <button id="albumBackBtn" class="drive-back-btn hidden" type="button" aria-label="Back to albums">
          <img src="icons/left.png" alt="Back">
        </button>
        <div class="photos-header">
          <h2 id="photosHeading">Photos</h2>
        </div>
        <div class="album-actions">
          <div class="dropdown">
            <button class="action-btn" id="albumMoreBtn" aria-haspopup="true" aria-expanded="false" aria-label="Album actions">
              <img src="icons/dots.png" alt="More">
            </button>
            <div class="dropdown-menu" id="albumMoreMenu">
              <button data-album-action="media-select" data-album-target="media"><span class="circle-check"><img src="icons/checkmark.png" alt=""></span>Select</button>
              <button data-album-action="album-select" data-album-target="album" class="album-grid-action"><span class="circle-check"><img src="icons/checkmark.png" alt=""></span>Select</button>
              <div class="dropdown-divider album-grid-action"></div>
              <button class="album-grid-action" data-album-sort="name-asc"><img src="icons/sort-ascending.png" alt="" class="inline-icon"> Name (ascending)</button>
              <button class="album-grid-action" data-album-sort="name-desc"><img src="icons/sort-descending.png" alt="" class="inline-icon"> Name (descending)</button>
              <button class="album-grid-action" data-album-sort="created-desc"><img src="icons/newest.png" alt="" class="inline-icon"> Newest (creation)</button>
              <button class="album-grid-action" data-album-sort="created-asc"><img src="icons/oldest.png" alt="" class="inline-icon"> Oldest (creation)</button>
              <div class="dropdown-divider album-grid-action"></div>
              <button class="album-grid-action" data-album-view="grid"><img src="icons/thumbnail.png" alt="" class="inline-icon"> Thumbnail View</button>
              <button class="album-grid-action" data-album-view="list"><img src="icons/list.png" alt="" class="inline-icon"> List View</button>
            </div>
          </div>
        </div>
      </div>
      <div id="albumGrid" class="album-grid"></div>
      <p id="albumEmpty" class="empty album-empty hidden">No albums yet. Tap <strong>New Album</strong> to create one.</p>
      <div id="albumMediaPanel" class="album-media-panel hidden">
        <div id="albumMedia" class="grid" aria-live="polite"></div>
        <p id="albumMediaEmpty" class="empty">This album is empty.</p>
      </div>
    </div>

    <!-- MARK:settings-shell -->
    <div class="settings-shell hidden">
      <div class="photos-header">
        <p class="eyebrow">Control Center</p>
        <h2>Settings</h2>
      </div>
      <div class="settings-tabs">
        <button type="button" class="active" data-settings-tab="themes">Themes</button>
        <button type="button" data-settings-tab="uploads">Uploads</button>
      </div>
      <div class="settings-panel" data-settings-panel="themes">
        <p class="settings-help" style="text-align:center; margin-bottom:24px;">Pick a background style for the Drive and Photos tabs.</p>
        <div id="themeGrid" class="theme-grid"></div>
      </div>
      <div class="settings-panel hidden" data-settings-panel="uploads">
        <form id="uploadSettingsForm">
          <label for="namingScheme">File naming template</label>
          <input id="namingScheme" name="namingScheme" type="text" placeholder="{{timestamp_human}}" maxlength="150">
          <p class="settings-help">Use tokens to build names. Available: <code>{{original}}</code>, <code>{{original_name}}</code>, <code>{{date}}</code>, <code>{{time}}</code>, <code>{{timestamp}}</code>, <code>{{timestamp_human}}</code>, <code>{{counter}}</code>.</p>
          <div class="token-list">
            <button type="button" data-token="{{original}}">{{original}}</button>
            <button type="button" data-token="{{original_name}}">{{original_name}}</button>
            <button type="button" data-token="{{date}}">{{date}}</button>
            <button type="button" data-token="{{time}}">{{time}}</button>
            <button type="button" data-token="{{timestamp}}">{{timestamp}}</button>
            <button type="button" data-token="{{timestamp_human}}">{{timestamp_human}}</button>
            <button type="button" data-token="{{counter}}">{{counter}}</button>
          </div>
          <div class="settings-preview">
            Preview: <strong id="namingPreview">photo-2024-01-01</strong>
          </div>
          <div class="settings-actions">
            <button type="submit">Save format</button>
          </div>
        </form>
      </div>
    </div>
  </main>
</div>



<p class="footer">PWA â€¢ Offline â€¢ Installable â€¢ Client-side storage</p>

<div id="albumModal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="albumModalTitle">
  <div class="modal-card">
    <h3 id="albumModalTitle">Create a new album</h3>
    <form id="albumForm">
      <label for="albumName">Name</label>
      <input id="albumName" name="albumName" type="text" placeholder="e.g. Summer 2024" required maxlength="60" autocomplete="off">
      <div class="modal-actions">
        <button type="button" id="albumCancel">Cancel</button>
        <button type="submit">Create</button>
      </div>
    </form>
  </div>
</div>

<!-- MARK:input-modal -->
<div id="inputModal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="inputModalTitle">
  <div class="modal-card">
    <h3 id="inputModalTitle">Enter value</h3>
    <form id="inputModalForm">
      <label for="inputModalField" id="inputModalLabel">Value</label>
      <input id="inputModalField" type="text" autocomplete="off" required>
      <div class="modal-actions">
        <button type="button" id="inputModalCancel">Cancel</button>
        <button type="submit" id="inputModalConfirm">Save</button>
      </div>
    </form>
  </div>
</div>

<!-- MARK:text-file-modal -->
<div id="textFileModal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="textFileModalTitle">
  <div class="modal-card">
    <h3 id="textFileModalTitle">New text file</h3>
    <form id="textFileForm">
      <label for="textFileName">Name</label>
      <input id="textFileName" type="text" required maxlength="120" autocomplete="off" placeholder="e.g. notes.txt">
      <label for="textFileContent">Content</label>
      <textarea id="textFileContent" rows="6" placeholder="Start typing..."></textarea>
      <div class="modal-actions">
        <button type="button" id="textFileCancel">Cancel</button>
        <button type="submit" id="textFileCreate">Create</button>
      </div>
    </form>
  </div>
</div>

<!-- MARK:list-picker-modal -->
<div id="listPickerModal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="listPickerTitle">
  <div class="modal-card">
    <h3 id="listPickerTitle">Select destination</h3>
    <div id="listPickerList" class="picker-list"></div>
    <div class="modal-actions">
      <button type="button" id="listPickerCancel">Cancel</button>
    </div>
  </div>
</div>

<!-- MARK:info-modal -->
<div id="infoModal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="infoModalTitle">
  <div class="modal-card info-card">
    <h3 id="infoModalTitle">File info</h3>
    <form id="infoForm">
      <label for="infoName">Display name</label>
      <input id="infoName" type="text" maxlength="200" autocomplete="off" required>
      <p class="info-original">Original name: <span id="infoOriginal">â€”</span></p>
      <dl class="info-grid" id="infoMetaList"></dl>
      <div class="modal-actions">
        <button type="button" id="infoCancel">Cancel</button>
        <button type="submit" id="infoSave">Save</button>
      </div>
    </form>
  </div>
</div>

<!-- MARK:photo-viewer -->
<div id="photoViewer" class="photo-viewer hidden" role="dialog" aria-modal="true" aria-labelledby="viewerTitle">
  <div class="viewer-frame">
    <div class="viewer-top">
      <div class="viewer-top-info">
        <strong id="viewerTitle"></strong>
        <span id="viewerDetails"></span>
      </div>
      <button id="viewerClose" type="button" class="icon-btn" title="Close">âœ•</button>
    </div>
    <div class="viewer-media" id="viewerMedia">
      <img id="viewerImage" alt="">
      <video id="viewerVideo" class="hidden" playsinline></video>
    </div>
    <div class="viewer-actions">
      <button id="actionMoveFolder" type="button" class="icon-btn" title="Move to folder"><img src="icons/expand.png" alt=""></button>
      <button id="actionAddAlbum" type="button" class="icon-btn" title="Add to album"><img src="icons/add-file.png" alt=""></button>
      <button id="actionSave" type="button" class="icon-btn" title="Save to device"><img src="icons/import.png" alt=""></button>
      <button id="actionInfo" type="button" class="icon-btn" title="Details"><img src="icons/info.png" alt=""></button>
      <button id="muteToggle" type="button" class="icon-btn hidden" title="Mute/unmute">ðŸ”‡</button>
    </div>
  </div>
</div>

<!-- MARK:bottom-tabs -->
<nav class="bottom-tabs" id="bottomTabs">
  <div class="tab-buttons">
    <button class="active" data-tab="folders">
      <span class="tab-icon"><img src="icons/folder.png" alt="Drive"></span>
      <span>Drive</span>
    </button>
    <button data-tab="albums">
      <span class="tab-icon"><img src="icons/gallery.png" alt="Photos"></span>
      <span>Photos</span>
    </button>
    <button data-tab="settings">
      <span class="tab-icon"><img src="icons/settings.png" alt="Settings"></span>
      <span>Settings</span>
    </button>
  </div>
  <div class="selection-actions hidden" id="selectionActions">
    <button type="button" id="selectionCancelBtn" title="Cancel selection"><img src="icons/cancel.png" alt="" class="inline-icon"></button>
    <button type="button" id="selectionAllBtn" title="Select all"><img src="icons/select-all.png" alt="" class="inline-icon"></button>
    <div id="mediaSelectionActions" class="selection-group">
      <button type="button" data-bulk="move" disabled title="Move"><img src="icons/expand.png" alt="" class="inline-icon"></button>
      <button type="button" data-bulk="copy" disabled title="Copy"><img src="icons/copy.png" alt="" class="inline-icon"></button>
      <button type="button" data-bulk="delete" disabled title="Delete"><img src="icons/remove-file.png" alt="" class="inline-icon"></button>
      <button type="button" data-bulk="album" disabled title="Add to album"><img src="icons/add-file.png" alt="" class="inline-icon"></button>
    </div>
    <div id="albumSelectionActions" class="selection-group hidden">
      <button type="button" id="copyAlbumsToFolderBtn" disabled title="Copy to folder"><img src="icons/expand.png" alt="" class="inline-icon"></button>
      <button type="button" id="copyAlbumsToAlbumBtn" disabled title="Copy to album"><img src="icons/gallery.png" alt="" class="inline-icon"></button>
      <button type="button" id="deleteAlbumsBtn" disabled title="Delete albums"><img src="icons/remove-file.png" alt="" class="inline-icon"></button>
    </div>
  </div>
</nav>

<script>
const basePath = "/pwa-photo-gallery/";

if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register(basePath + 'sw.js').catch(console.error);
  });
}

let deferredPrompt;
const installBtn = document.getElementById('installBtn');
window.addEventListener('beforeinstallprompt', (e) => {
  e.preventDefault();
  deferredPrompt = e;
  installBtn.classList.remove('hidden');
});
installBtn?.addEventListener('click', async () => {
  if (!deferredPrompt) return;
  deferredPrompt.prompt();
  await deferredPrompt.userChoice;
  deferredPrompt = null;
  installBtn.classList.add('hidden');
});

function idbOpen(dbName, version) {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(dbName, version);
    req.onupgradeneeded = (event) => {
      const db = req.result;
      let photoStore;
      if (!db.objectStoreNames.contains(STORE)) {
        photoStore = db.createObjectStore(STORE, { keyPath: 'id', autoIncrement: true });
      } else {
        photoStore = req.transaction.objectStore(STORE);
      }
      if (!photoStore.indexNames.contains('created')) photoStore.createIndex('created', 'created');
      if (!photoStore.indexNames.contains('folderId')) photoStore.createIndex('folderId', 'folderId');
      if (!photoStore.indexNames.contains('albumId')) photoStore.createIndex('albumId', 'albumId');

      let folderStoreRef;
      if (!db.objectStoreNames.contains(FOLDER_STORE)) {
        folderStoreRef = db.createObjectStore(FOLDER_STORE, { keyPath: 'id', autoIncrement: true });
        folderStoreRef.createIndex('name', 'name', { unique: false });
      } else {
        folderStoreRef = req.transaction.objectStore(FOLDER_STORE);
      }
      if (event.oldVersion < 4 && folderStoreRef) {
        folderStoreRef.openCursor().onsuccess = (ev) => {
          const cursor = ev.target.result;
          if (cursor) {
            const value = cursor.value;
            if (!('parentId' in value)) {
              value.parentId = null;
              cursor.update(value);
            }
            cursor.continue();
          }
        };
      }
      if (event.oldVersion < 3) {
        if (!db.objectStoreNames.contains(COLLECTION_STORE)) {
          const albums = db.createObjectStore(COLLECTION_STORE, { keyPath: 'id', autoIncrement: true });
          albums.createIndex('name', 'name', { unique: false });
        }
        if (!db.objectStoreNames.contains(COLLECTION_ITEMS_STORE)) {
          const items = db.createObjectStore(COLLECTION_ITEMS_STORE, { keyPath: 'id' });
          items.createIndex('albumId', 'albumId', { unique: false });
          items.createIndex('photoId', 'photoId', { unique: false });
        }
      }
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}
function idbAdd(db, store, value) {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(store, 'readwrite');
    const req = tx.objectStore(store).add(value);
    tx.oncomplete = () => resolve(req.result);
    tx.onerror = () => reject(tx.error);
  });
}
function idbPut(db, store, value) {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(store, 'readwrite');
    tx.objectStore(store).put(value);
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
}
function idbAll(db, store) {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(store, 'readonly');
    const req = tx.objectStore(store).getAll();
    req.onsuccess = () => resolve(req.result || []);
    req.onerror = () => reject(req.error);
  });
}
function idbClear(db, store) {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(store, 'readwrite');
    tx.objectStore(store).clear();
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
}
function idbDelete(db, store, key) {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(store, 'readwrite');
    tx.objectStore(store).delete(key);
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
}

const DB_NAME = 'pwa-photo-album';
const DB_VERSION = 4;
const STORE = 'photos';
const FOLDER_STORE = 'albums';
const COLLECTION_STORE = 'collections';
const COLLECTION_ITEMS_STORE = 'collection_items';
const SPECIAL_ALL = 'all';
const SPECIAL_UNSORTED = 'unsorted';
const TAB_FOLDERS = 'folders';
const TAB_ALBUMS = 'albums';
const TAB_SETTINGS = 'settings';

let db;
let folders = [];
let albums = [];
let albumMembership = new Map();
let photoCache = [];
let currentFolder = SPECIAL_ALL;
let currentAlbumId = null;
let activeTab = TAB_FOLDERS;
let modalContext = 'folder';

// MARK:dom-refs
const folderListEl = document.getElementById('folderList');
const albumTitleEl = document.getElementById('activeAlbumTitle');
const photosHeadingEl = document.getElementById('photosHeading');
const emptyAlbumLabel = document.getElementById('emptyAlbumLabel');
const bottomTabsEl = document.getElementById('bottomTabs');
const selectionActionsEl = document.getElementById('selectionActions');
const tabButtons = document.querySelectorAll('.tab-buttons button[data-tab]');
const selectionActionButtons = selectionActionsEl ? Array.from(selectionActionsEl.querySelectorAll('button[data-bulk]')) : [];
const selectionCancelBtn = document.getElementById('selectionCancelBtn');
const selectionAllBtn = document.getElementById('selectionAllBtn');
const mediaSelectionGroup = document.getElementById('mediaSelectionActions');
const albumSelectionGroup = document.getElementById('albumSelectionActions');
const copyAlbumsToFolderBtn = document.getElementById('copyAlbumsToFolderBtn');
const copyAlbumsToAlbumBtn = document.getElementById('copyAlbumsToAlbumBtn');
const deleteAlbumsBtn = document.getElementById('deleteAlbumsBtn');
const inputModal = document.getElementById('inputModal');
const inputModalTitle = document.getElementById('inputModalTitle');
const inputModalLabel = document.getElementById('inputModalLabel');
const inputModalField = document.getElementById('inputModalField');
const inputModalForm = document.getElementById('inputModalForm');
const inputModalCancel = document.getElementById('inputModalCancel');
const inputModalConfirm = document.getElementById('inputModalConfirm');
const textFileModal = document.getElementById('textFileModal');
const textFileForm = document.getElementById('textFileForm');
const textFileNameInput = document.getElementById('textFileName');
const textFileContentInput = document.getElementById('textFileContent');
const textFileCancel = document.getElementById('textFileCancel');
const listPickerModal = document.getElementById('listPickerModal');
const listPickerTitle = document.getElementById('listPickerTitle');
const listPickerList = document.getElementById('listPickerList');
const listPickerCancel = document.getElementById('listPickerCancel');
let listPickerModalResolver = null;
const listPickerPreviewUrls = [];
const mediaUrlCache = new Map();
const pendingPreviewIds = new Set();
const infoModal = document.getElementById('infoModal');
const infoForm = document.getElementById('infoForm');
const infoNameInput = document.getElementById('infoName');
const infoOriginalEl = document.getElementById('infoOriginal');
const infoMetaList = document.getElementById('infoMetaList');
const infoCancelBtn = document.getElementById('infoCancel');
const modal = document.getElementById('albumModal');
const albumModalTitle = document.getElementById('albumModalTitle');
const albumForm = document.getElementById('albumForm');
const albumInput = document.getElementById('albumName');
const albumCancel = document.getElementById('albumCancel');
const settingsTabButtons = document.querySelectorAll('[data-settings-tab]');
const settingsPanels = document.querySelectorAll('[data-settings-panel]');
const uploadSettingsForm = document.getElementById('uploadSettingsForm');
const tokenButtons = uploadSettingsForm ? uploadSettingsForm.querySelectorAll('button[data-token]') : [];
const namingInput = document.getElementById('namingScheme');
const namingPreview = document.getElementById('namingPreview');
const photoViewer = document.getElementById('photoViewer');
const viewerClose = document.getElementById('viewerClose');
const viewerImg = document.getElementById('viewerImage');
const viewerVideo = document.getElementById('viewerVideo');
const viewerTitle = document.getElementById('viewerTitle');
const viewerDetails = document.getElementById('viewerDetails');
const viewerMediaEl = document.getElementById('viewerMedia');
const actionMoveFolder = document.getElementById('actionMoveFolder');
const actionAddAlbumBtn = document.getElementById('actionAddAlbum');
const actionSave = document.getElementById('actionSave');
const actionInfo = document.getElementById('actionInfo');
const muteToggle = document.getElementById('muteToggle');
const input = document.getElementById('fileInput');
const clearBtn = document.getElementById('clearBtn');
const exportBtn = document.getElementById('exportBtn');
const driveItemsEl = document.getElementById('driveItems');
const driveSearchInput = document.getElementById('driveSearch');
const primaryAddBtn = document.getElementById('primaryAddBtn');
const moreActionsBtn = document.getElementById('moreActionsBtn');
const addMenu = document.getElementById('addMenu');
const moreMenu = document.getElementById('moreMenu');
const driveShellEl = document.querySelector('.drive-shell');
const driveBackBtn = document.getElementById('driveBackBtn');
const albumShellEl = document.querySelector('.album-shell');
const albumGridEl = document.getElementById('albumGrid');
const albumEmptyEl = document.getElementById('albumEmpty');
const albumMediaPanel = document.getElementById('albumMediaPanel');
const albumMediaEl = document.getElementById('albumMedia');
const albumMediaEmptyEl = document.getElementById('albumMediaEmpty');
const albumBackBtn = document.getElementById('albumBackBtn');
const albumMoreBtn = document.getElementById('albumMoreBtn');
const albumMoreMenu = document.getElementById('albumMoreMenu');
const settingsShellEl = document.querySelector('.settings-shell');
const settingsThemeGridEl = document.getElementById('themeGrid');

let viewerUrl;
let currentViewList = [];
let currentViewerIndex = -1;
let mediaSortMode = 'created-desc';
let selectionMode = false;
let selectedFolders = new Set();
let selectedMedia = new Set();
let selectedAlbums = new Set();
let driveSearchTerm = '';
let visibleFolderIds = [];
let visibleMediaIds = [];
let visibleAlbumIds = [];
let albumSortMode = 'name-asc';
let inputModalResolver = null;
let textFileModalResolver = null;
const SETTINGS_KEY = 'pwa-photo-gallery-settings';
const defaultSettings = {
  namingScheme: '{{timestamp_human}}',
  counter: 1,
  theme: 'dark',
  viewPrefs: {
    folders: {},
    albumGrid: 'grid'
  }
};
let settings = loadSettings();
ensureViewPrefsShape(settings);
if (!settings.namingScheme || settings.namingScheme === '{{original}}') {
  settings.namingScheme = defaultSettings.namingScheme;
  saveSettings();
}
if (namingInput) {
  namingInput.value = settings.namingScheme || defaultSettings.namingScheme;
}
let driveViewMode = getFolderViewMode(currentFolder);
let albumViewMode = settings.viewPrefs?.albumGrid || 'grid';
let activeSettingsPanel = 'themes';
let chromeHidden = false;
let isZoomed = false;
let panX = 0;
let panY = 0;
let lastTapTime = 0;
let tapTimeout;
const gesture = { active: false, pointerId: null, startX: 0, startY: 0, initialX: 0, initialY: 0, panMode: false, startTime: 0 };

// MARK:theme-data
const THEMES = [
  {
    id: 'dark',
    name: 'Midnight',
    description: 'Deep navy system default',
    preview: ['#050812', '#0f172a'],
    vars: {
      '--bg': '#050812',
      '--card': '#0f172a',
      '--muted': '#94a3b8',
      '--text': '#f1f5f9',
      '--accent': '#38bdf8',
      '--accent-strong': '#0ea5e9',
      '--sidebar': '#0b1220',
      '--bg-pattern': 'radial-gradient(circle at top, rgba(56,189,248,.25), transparent 45%)',
      '--icon-filter': 'invert(1) brightness(1.6)'
    }
  },
  {
    id: 'light',
    name: 'Aurora Light',
    description: 'Bright neutral workstation',
    preview: ['#f8fafc', '#e2e8f0'],
    vars: {
      '--bg': '#f8fafc',
      '--card': '#ffffff',
      '--muted': '#64748b',
      '--text': '#0f172a',
      '--accent': '#e7e9ef',
      '--accent-strong': '#d4d8e2',
      '--sidebar': '#e2e8f0',
      '--bg-pattern': 'radial-gradient(circle at top, rgba(37,99,235,.12), transparent 45%)',
      '--icon-filter': 'invert(0)'
    }
  },
  {
    id: 'aurora',
    name: 'Aurora Neon',
    description: 'Teal & purple glow',
    preview: ['#021f2a', '#162243'],
    vars: {
      '--bg': '#011018',
      '--card': '#061e2b',
      '--muted': '#8cd9ff',
      '--text': '#e6f9ff',
      '--accent': '#5ef1cb',
      '--accent-strong': '#34d1f6',
      '--sidebar': '#041421',
      '--bg-pattern': 'radial-gradient(circle at top, rgba(94,241,203,.35), transparent 45%)',
      '--icon-filter': 'invert(1) brightness(1.6)'
    }
  }
];

function applyTheme(themeId, persist = false) {
  const theme = THEMES.find(t => t.id === themeId) || THEMES[0];
  if (!theme) return;
  Object.entries(theme.vars).forEach(([key, value]) => {
    document.documentElement.style.setProperty(key, value);
  });
  if (persist) {
    settings.theme = theme.id;
    saveSettings();
  }
}

function renderThemes() {
  if (!settingsThemeGridEl) return;
  settingsThemeGridEl.innerHTML = '';
  const activeId = settings.theme || defaultSettings.theme;
  THEMES.forEach((theme) => {
    const card = document.createElement('button');
    card.type = 'button';
    card.className = 'theme-card' + (theme.id === activeId ? ' active' : '');
    const preview = document.createElement('div');
    preview.className = 'theme-preview';
    preview.style.background = `linear-gradient(135deg, ${theme.preview[0]}, ${theme.preview[1]})`;
    const meta = document.createElement('div');
    meta.className = 'theme-meta';
    const title = document.createElement('strong');
    title.textContent = theme.name;
    const desc = document.createElement('span');
    desc.style.color = 'var(--muted)';
    desc.textContent = theme.description;
    meta.append(title, desc);
    card.append(preview, meta);
    card.addEventListener('click', () => {
      applyTheme(theme.id, true);
      renderThemes();
    });
    settingsThemeGridEl.appendChild(card);
  });
}

applyTheme(settings.theme || defaultSettings.theme, false);
renderThemes();

// MARK:modal-helpers
function openInputModal({ title = 'Input', label = 'Value', value = '', placeholder = '', confirmText = 'Save', required = true } = {}) {
  if (!inputModal) return Promise.resolve(null);
  inputModalTitle.textContent = title;
  inputModalLabel.textContent = label;
  inputModalField.value = value || '';
  inputModalField.placeholder = placeholder || '';
  inputModalField.required = required;
  inputModalConfirm.textContent = confirmText || 'Save';
  inputModal.classList.remove('hidden');
  setTimeout(() => inputModalField.focus(), 20);
  return new Promise((resolve) => {
    inputModalResolver = resolve;
  });
}

function closeInputModal(result) {
  if (inputModal) inputModal.classList.add('hidden');
  if (inputModalResolver) {
    const output = typeof result === 'string' ? result.trim() : result;
    inputModalResolver(output ?? null);
    inputModalResolver = null;
  }
}

inputModalCancel?.addEventListener('click', () => closeInputModal(null));
inputModal?.addEventListener('click', (e) => { if (e.target === inputModal) closeInputModal(null); });
inputModalForm?.addEventListener('submit', (e) => {
  e.preventDefault();
  const value = inputModalField.value.trim();
  if (inputModalField.required && !value) {
    inputModalField.focus();
    return;
  }
  closeInputModal(value);
});

function openTextFileModal(defaultName = 'notes.txt') {
  if (!textFileModal) return Promise.resolve(null);
  textFileNameInput.value = defaultName || 'notes.txt';
  textFileContentInput.value = '';
  textFileModal.classList.remove('hidden');
  setTimeout(() => textFileNameInput.focus(), 20);
  return new Promise((resolve) => {
    textFileModalResolver = resolve;
  });
}

function closeTextFileModal(result) {
  if (textFileModal) textFileModal.classList.add('hidden');
  if (textFileModalResolver) {
    textFileModalResolver(result ?? null);
    textFileModalResolver = null;
  }
}

textFileCancel?.addEventListener('click', () => closeTextFileModal(null));
textFileModal?.addEventListener('click', (e) => { if (e.target === textFileModal) closeTextFileModal(null); });
textFileForm?.addEventListener('submit', (e) => {
  e.preventDefault();
  const name = textFileNameInput.value.trim();
  if (!name) {
    textFileNameInput.focus();
    return;
  }
  closeTextFileModal({ name, content: textFileContentInput.value || '' });
});

function trackPickerPreviewUrl(url) {
  if (!url) return;
  listPickerPreviewUrls.push(url);
}

function cleanupPickerPreviews() {
  while (listPickerPreviewUrls.length) {
    const url = listPickerPreviewUrls.pop();
    URL.revokeObjectURL(url);
  }
}

function openListPicker({ title, items }) {
  if (!listPickerModal) return Promise.resolve(null);
  cleanupPickerPreviews();
  listPickerTitle.textContent = title || 'Select option';
  listPickerList.innerHTML = '';
  const entries = Array.isArray(items) ? items : [];
  entries.forEach((item) => {
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'picker-card';
    const thumb = document.createElement('div');
    thumb.className = 'picker-thumb';
    const preview = item.previewMedia;
    if (preview) {
      const isVideo = preview.kind === 'video' || preview.type?.startsWith('video/');
      const isText = preview.kind === 'text' || preview.type === 'text/plain';
      if (isText) {
        const textBlock = document.createElement('div');
        textBlock.className = 'picker-thumb-text';
        textBlock.textContent = preview.preview || preview.name || 'Text file';
        thumb.appendChild(textBlock);
      } else if (isVideo || preview.blob) {
        const mediaEl = document.createElement(isVideo ? 'video' : 'img');
        if (isVideo) {
          mediaEl.muted = true;
          mediaEl.loop = true;
          mediaEl.playsInline = true;
          mediaEl.autoplay = true;
        } else {
          mediaEl.loading = 'lazy';
          mediaEl.alt = item.label || '';
        }
        const url = URL.createObjectURL(preview.blob);
        trackPickerPreviewUrl(url);
        mediaEl.src = url;
        thumb.appendChild(mediaEl);
      } else {
        const fallback = document.createElement('img');
        fallback.src = item.icon || 'icons/folder.png';
        fallback.alt = '';
        fallback.className = 'picker-thumb-icon';
        thumb.appendChild(fallback);
      }
    } else {
      const icon = document.createElement('img');
      icon.src = item.icon || 'icons/folder.png';
      icon.alt = '';
      icon.className = 'picker-thumb-icon';
      thumb.appendChild(icon);
    }
    btn.appendChild(thumb);
    const label = document.createElement('span');
    label.className = 'picker-label';
    label.textContent = item.label || 'Untitled';
    btn.appendChild(label);
    if (item.subtitle) {
      const subtitle = document.createElement('span');
      subtitle.className = 'picker-subtitle';
      subtitle.textContent = item.subtitle;
      btn.appendChild(subtitle);
    }
    btn.addEventListener('click', () => closeListPicker(item.value));
    listPickerList.appendChild(btn);
  });
  if (!entries.length) {
    const empty = document.createElement('p');
    empty.className = 'empty';
    empty.textContent = 'No options available.';
    listPickerList.appendChild(empty);
  }
  listPickerModal.classList.remove('hidden');
  return new Promise((resolve) => {
    listPickerModalResolver = resolve;
  });
}

function closeListPicker(value) {
  if (listPickerModal) {
    listPickerModal.classList.add('hidden');
    if (listPickerList) listPickerList.innerHTML = '';
  }
  cleanupPickerPreviews();
  if (listPickerModalResolver) {
    listPickerModalResolver(value);
    listPickerModalResolver = null;
  }
}

listPickerCancel?.addEventListener('click', () => closeListPicker(undefined));
listPickerModal?.addEventListener('click', (e) => {
  if (e.target === listPickerModal) closeListPicker(undefined);
});
listPickerModal?.addEventListener('mousedown', (e) => {
  if (e.target === listPickerModal) closeListPicker(undefined);
});

let infoModalResolver = null;

function openInfoModal(item) {
  if (!infoModal || !infoNameInput) return Promise.resolve(null);
  infoNameInput.value = item.name || formatTimestampName(item.captured ?? item.created);
  if (infoOriginalEl) infoOriginalEl.textContent = item.originalName || item.name || 'â€”';
  renderInfoMetadata(item);
  infoModal.classList.remove('hidden');
  setTimeout(() => infoNameInput.focus(), 20);
  return new Promise((resolve) => {
    infoModalResolver = resolve;
  });
}

function closeInfoModal(result) {
  if (infoModal) infoModal.classList.add('hidden');
  if (infoModalResolver) {
    infoModalResolver(result ?? null);
    infoModalResolver = null;
  }
}

function renderInfoMetadata(item) {
  if (!infoMetaList) return;
  const folderLabel = folderTitleFor(
    item.folderId == null ? SPECIAL_ALL : item.folderId
  );
  const rows = [
    ['Type', item.type || item.kind || 'â€”'],
    ['Size', formatFileSize(item.size)],
    ['Dimensions', item.width && item.height ? `${item.width}Ã—${item.height}` : 'â€”'],
    ['Duration', item.kind === 'video' ? formatDuration(item.duration) : 'â€”'],
    ['Created', new Date(item.created).toLocaleString()],
    ['Captured', new Date(item.captured ?? item.created).toLocaleString()],
    ['Folder', folderLabel]
  ];
  infoMetaList.innerHTML = '';
  rows.forEach(([label, value]) => {
    const dt = document.createElement('dt');
    dt.textContent = label;
    const dd = document.createElement('dd');
    dd.textContent = value || 'â€”';
    infoMetaList.append(dt, dd);
  });
}

infoCancelBtn?.addEventListener('click', () => closeInfoModal(null));
infoModal?.addEventListener('click', (e) => {
  if (e.target === infoModal) closeInfoModal(null);
});
infoForm?.addEventListener('submit', (e) => {
  e.preventDefault();
  const name = (infoNameInput?.value || '').trim();
  if (!name) {
    infoNameInput?.focus();
    return;
  }
  closeInfoModal({ name });
});

(async () => {
  db = await idbOpen(DB_NAME, DB_VERSION);
  await ensureFolderSeed();
  await loadFolders();
  await loadCollections();
  await refreshGallery();
  setActiveTab(TAB_FOLDERS);
})();

async function ensureFolderSeed() {
  // no-op: user decides when to create their first folder
}

async function loadFolders() {
  folders = await idbAll(db, FOLDER_STORE);
  folders.forEach(folder => {
    if (folder.parentId === undefined) folder.parentId = null;
  });
  folders.sort((a, b) => a.name.localeCompare(b.name));
  renderFolderList();
  if (typeof currentFolder === 'number' && !folders.find(f => f.id === currentFolder)) {
    currentFolder = SPECIAL_ALL;
  }
  selectedFolders.clear();
  selectedMedia.clear();
  renderGallery();
  updateHeader();
}

function renderFolderList() {
  if (!folderListEl) return;
  folderListEl.innerHTML = '';
  const counts = photoCache.reduce((acc, photo) => {
    const key = photo.folderId ?? SPECIAL_UNSORTED;
    acc[key] = (acc[key] || 0) + 1;
    return acc;
  }, {});
  const entries = [
    { id: SPECIAL_ALL, name: 'All Media', icon: 'icons/folder.png', count: photoCache.length },
    { id: SPECIAL_UNSORTED, name: 'Main Library', icon: 'icons/import.png', count: counts[SPECIAL_UNSORTED] || 0 }
  ];
  for (const folder of folders) {
    entries.push({ id: folder.id, name: folder.name, icon: 'icons/folder.png', count: counts[folder.id] || 0 });
  }
  for (const entry of entries) {
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'album-item' + (currentFolder === entry.id ? ' active' : '');
    btn.dataset.folder = String(entry.id);
    const icon = document.createElement('span');
    icon.className = 'album-icon list-icon';
    const img = document.createElement('img');
    img.src = entry.icon;
    img.alt = '';
    icon.appendChild(img);
    const meta = document.createElement('div');
    meta.className = 'album-meta';
    const title = document.createElement('strong');
    title.textContent = entry.name;
    const count = document.createElement('span');
    const n = entry.count || 0;
    count.textContent = n ? `${n} item${n === 1 ? '' : 's'}` : 'Empty';
    meta.append(title, count);
    btn.append(icon, meta);
    folderListEl.appendChild(btn);
  }
}

folderListEl?.addEventListener('click', (event) => {
  const target = event.target.closest('button[data-folder]');
  if (!target) return;
  const value = target.dataset.folder;
  if (value === SPECIAL_ALL || value === SPECIAL_UNSORTED) {
    setActiveFolder(value);
  } else {
    setActiveFolder(Number(value));
  }
});

function createFolderCard(folder, count = 0) {
  const card = document.createElement('button');
  card.type = 'button';
  const isSelected = selectedFolders.has(folder.id);
  const isActive = folder.id === currentFolder;
  card.className = 'folder-card' + (isActive ? ' active' : '') + (isSelected ? ' selected' : '');
  card.dataset.folderId = String(folder.id);
  const indicator = document.createElement('span');
  indicator.className = 'select-indicator';
  card.appendChild(indicator);
  const iconWrap = document.createElement('div');
  iconWrap.className = 'folder-icon-wrap';
  const iconImg = document.createElement('img');
  iconImg.src = 'icons/folder-color.png';
  iconImg.alt = '';
  iconImg.loading = 'lazy';
  iconWrap.appendChild(iconImg);
  card.appendChild(iconWrap);
  const name = document.createElement('div');
  name.className = 'name';
  name.textContent = folder.name;
  const meta = document.createElement('div');
  meta.className = 'count';
  meta.textContent = count ? `${count} item${count === 1 ? '' : 's'}` : 'Empty';
  card.append(name, meta);
  card.addEventListener('click', () => {
    if (selectionMode) {
      if (selectedFolders.has(folder.id)) {
        selectedFolders.delete(folder.id);
        card.classList.remove('selected');
      } else {
        selectedFolders.add(folder.id);
        card.classList.add('selected');
      }
      updateSelectionChrome();
      return;
    }
    setActiveFolder(folder.id);
  });
  return card;
}

function createMediaTile(item, idx) {
  const card = document.createElement('button');
  card.type = 'button';
  const isSelected = selectedMedia.has(item.id);
  card.className = 'folder-card media-card' + (isSelected ? ' selected' : '');
  card.dataset.mediaId = String(item.id);
  const indicator = document.createElement('span');
  indicator.className = 'select-indicator';
  card.appendChild(indicator);
  const thumb = document.createElement('div');
  thumb.className = 'thumb';
  const isVideo = item.kind === 'video' || item.type?.startsWith('video/');
  const isText = item.kind === 'text' || item.type === 'text/plain';
  if (isText) {
    const textPreview = document.createElement('div');
    textPreview.className = 'text-card';
    textPreview.textContent = item.preview || item.name || 'Text file';
    thumb.appendChild(textPreview);
  } else {
    const asset = getThumbnailAsset(item);
    if (asset) {
      const img = document.createElement('img');
      img.loading = 'lazy';
      img.decoding = 'async';
      img.alt = item.name || 'Media file';
      img.src = asset.url;
      img.dataset.thumbKey = asset.key;
      thumb.appendChild(img);
    } else {
      const placeholder = document.createElement('div');
      placeholder.className = 'text-card';
      placeholder.textContent = item.name || 'Media file';
      thumb.appendChild(placeholder);
    }
  }
  if (isVideo) {
    const flag = document.createElement('span');
    flag.className = 'media-flag';
    flag.textContent = 'ðŸŽ¬ Video';
    card.appendChild(flag);
  }
  card.appendChild(thumb);
  const name = document.createElement('div');
  name.className = 'name';
  name.textContent = item.name || 'Untitled';
  card.appendChild(name);
    if (driveViewMode === 'list') {
      const meta = document.createElement('div');
      meta.className = 'meta';
      const stamp = document.createElement('span');
      stamp.textContent = new Date(item.created).toLocaleDateString();
      const chip = document.createElement('span');
      chip.className = 'chip';
      chip.textContent = isVideo ? formatDuration(item.duration) : (isText ? 'Text file' : `${item.width}Ã—${item.height}`);
      meta.append(stamp, chip);
      card.appendChild(meta);
    }
  card.addEventListener('click', () => {
    if (selectionMode) {
      if (selectedMedia.has(item.id)) {
        selectedMedia.delete(item.id);
        card.classList.remove('selected');
      } else {
        selectedMedia.add(item.id);
        card.classList.add('selected');
      }
      updateSelectionChrome();
      return;
    }
    openViewerAt(idx);
  });
  return card;
}

function renderAlbumGrid() {
  if (!albumGridEl) return;
  const showingAlbums = !currentAlbumId;
  albumGridEl.classList.toggle('hidden', !showingAlbums);
  albumGridEl.classList.toggle('list-view', albumViewMode === 'list');
  albumBackBtn?.classList.toggle('hidden', showingAlbums);
  if (!showingAlbums) {
    visibleAlbumIds = [];
    albumEmptyEl?.classList.add('hidden');
    return;
  }
  albumGridEl.innerHTML = '';
  const emptyMsg = albumEmptyEl;
  const fragment = document.createDocumentFragment();
  const list = albums.slice();
  list.sort((a, b) => {
    switch (albumSortMode) {
      case 'name-desc':
        return (b.name || '').localeCompare(a.name || '');
      case 'created-asc':
        return (a.created || 0) - (b.created || 0);
      case 'created-desc':
        return (b.created || 0) - (a.created || 0);
      case 'name-asc':
      default:
        return (a.name || '').localeCompare(b.name || '');
    }
  });
  visibleAlbumIds = list.map(album => album.id);
  selectedAlbums.forEach(id => { if (!visibleAlbumIds.includes(id)) selectedAlbums.delete(id); });

  const newCard = document.createElement('button');
  newCard.type = 'button';
  newCard.className = 'album-card new';
  const newThumb = document.createElement('div');
  newThumb.className = 'album-card-thumb';
  const plus = document.createElement('div');
  plus.className = 'album-new-icon';
  plus.textContent = 'ï¼‹';
  newThumb.appendChild(plus);
  const newBody = document.createElement('div');
  newBody.className = 'album-card-body';
  const newTitle = document.createElement('div');
  newTitle.className = 'title';
  newTitle.textContent = 'New Album';
  const newCount = document.createElement('div');
  newCount.className = 'count';
  newCount.textContent = '';
  newBody.append(newTitle, newCount);
  newCard.append(newThumb, newBody);
  newCard.addEventListener('click', () => openCreateModal('album'));
  fragment.appendChild(newCard);

  if (!albums.length) {
    albumGridEl.appendChild(fragment);
    emptyMsg?.classList.remove('hidden');
    return;
  }
  emptyMsg?.classList.add('hidden');

  list.forEach((album) => {
    const count = albumMembership.get(album.id)?.size || 0;
    const label = count === 1 ? '1 item' : `${count} items`;
    const card = document.createElement('button');
    card.type = 'button';
    const isActive = album.id === currentAlbumId;
    const isSelected = selectedAlbums.has(album.id);
    card.className = 'album-card' + (isActive ? ' active' : '') + (isSelected ? ' selected' : '');
    card.dataset.albumId = String(album.id);
    const selector = document.createElement('span');
    selector.className = 'select-indicator';
    card.appendChild(selector);
    const thumb = document.createElement('div');
    thumb.className = 'album-card-thumb';
    const preview = getAlbumPreviewMedia(album.id);
    if (preview) {
      const isText = preview.kind === 'text' || preview.type === 'text/plain';
      if (isText) {
        const textBlock = document.createElement('div');
        textBlock.className = 'album-thumb-text';
        textBlock.textContent = preview.preview || preview.name || 'Text file';
        thumb.appendChild(textBlock);
      } else {
        const asset = getThumbnailAsset(preview);
        if (asset) {
          const media = document.createElement('img');
          media.loading = 'lazy';
          media.decoding = 'async';
          media.alt = album.name;
          media.src = asset.url;
          media.dataset.thumbKey = asset.key;
          thumb.appendChild(media);
        }
      }
    }
    if (!thumb.childNodes.length) {
      const placeholder = document.createElement('img');
      placeholder.src = 'icons/gallery.png';
      placeholder.alt = '';
      placeholder.className = 'thumb-placeholder';
      thumb.appendChild(placeholder);
    }
    const body = document.createElement('div');
    body.className = 'album-card-body';
    const title = document.createElement('div');
    title.className = 'title';
    title.textContent = album.name;
    const countLabel = document.createElement('div');
    countLabel.className = 'count';
    countLabel.textContent = label;
    body.append(title, countLabel);
    card.append(thumb, body);
    card.addEventListener('click', () => {
      if (selectionMode && !currentAlbumId) {
        if (selectedAlbums.has(album.id)) {
          selectedAlbums.delete(album.id);
          card.classList.remove('selected');
        } else {
          selectedAlbums.add(album.id);
          card.classList.add('selected');
        }
        updateSelectionChrome();
        return;
      }
      setActiveAlbum(album.id);
    });
    fragment.appendChild(card);
  });

  albumGridEl.appendChild(fragment);
  updateSelectionChrome();
}

function setActiveFolder(value) {
  let target = value;
  if (value === SPECIAL_ALL || value === String(SPECIAL_ALL)) {
    target = SPECIAL_ALL;
  } else if (value === SPECIAL_UNSORTED || value == null) {
    target = SPECIAL_ALL;
  } else if (typeof value === 'string') {
    target = Number(value);
  }
  currentFolder = target;
  driveViewMode = getFolderViewMode(currentFolder);
  resetDriveSearch();
  selectedFolders.clear();
  selectedMedia.clear();
  selectedAlbums.clear();
  updateSelectionChrome();
  const wasTab = activeTab;
  setActiveTab(TAB_FOLDERS);
  if (wasTab !== TAB_FOLDERS) return;
  if (!photoViewer.classList.contains('hidden')) closeViewer();
  renderFolderList();
  updateHeader();
  renderGallery();
}

function folderTitleFor(id) {
  if (id === SPECIAL_ALL) return 'Drive';
  if (id === SPECIAL_UNSORTED) return 'Main Library';
  const found = getFolderById(id);
  return found?.name || 'Folder';
}

function getFolderById(id) {
  if (typeof id !== 'number') return null;
  return folders.find(f => f.id === Number(id)) || null;
}

function getFolderParentId(id) {
  const folder = getFolderById(id);
  return folder?.parentId ?? null;
}

async function loadCollections() {
  albums = await idbAll(db, COLLECTION_STORE);
  albums.sort((a, b) => a.name.localeCompare(b.name));
  const items = await idbAll(db, COLLECTION_ITEMS_STORE);
  albumMembership = new Map();
  for (const entry of items) {
    if (!albumMembership.has(entry.albumId)) albumMembership.set(entry.albumId, new Set());
    albumMembership.get(entry.albumId).add(entry.photoId);
  }
  if (currentAlbumId && !albums.find(a => a.id === currentAlbumId)) {
    currentAlbumId = null;
  }
  renderAlbumGrid();
  renderGallery();
  updateHeader();
}

function setActiveAlbum(id) {
  if (id && selectionMode) toggleSelectionMode(false);
  currentAlbumId = id || null;
  setActiveTab(TAB_ALBUMS);
  if (!photoViewer.classList.contains('hidden')) closeViewer();
  renderAlbumGrid();
  updateHeader();
  renderGallery();
}

function albumTitleFor(id) {
  const found = albums.find(a => a.id === Number(id));
  return found?.name || 'Album';
}

function setActiveTab(tab) {
  activeTab = tab;
  tabButtons.forEach(btn => btn.classList.toggle('active', btn.dataset.tab === tab));
  driveShellEl?.classList.toggle('hidden', tab !== TAB_FOLDERS);
  albumShellEl?.classList.toggle('hidden', tab !== TAB_ALBUMS);
  settingsShellEl?.classList.toggle('hidden', tab !== TAB_SETTINGS);
  if (tab === TAB_FOLDERS) {
    driveViewMode = getFolderViewMode(currentFolder);
  }
  if (tab === TAB_SETTINGS) {
    setSettingsPanel(activeSettingsPanel || 'themes');
  }
  if (tab === TAB_SETTINGS && selectionMode) {
    toggleSelectionMode(false);
  }
  updateHeader();
  renderFolderList();
  renderAlbumGrid();
  renderGallery();
}

tabButtons.forEach(btn => btn.addEventListener('click', () => {
  const tab = btn.dataset.tab;
  switch (tab) {
    case TAB_FOLDERS:
      setActiveTab(TAB_FOLDERS);
      break;
    case TAB_ALBUMS:
      setActiveTab(TAB_ALBUMS);
      break;
    case TAB_SETTINGS:
      setActiveTab(TAB_SETTINGS);
      break;
    default:
      alert('This tab is coming soon.');
      break;
  }
}));

function setSettingsPanel(panelId = 'themes') {
  const resolved = panelId === 'uploads' ? 'uploads' : 'themes';
  activeSettingsPanel = resolved;
  settingsTabButtons.forEach(btn => {
    btn.classList.toggle('active', btn.dataset.settingsTab === resolved);
  });
  settingsPanels.forEach(panel => {
    panel.classList.toggle('hidden', panel.dataset.settingsPanel !== resolved);
  });
  if (resolved === 'uploads' && namingInput) {
    namingInput.value = settings.namingScheme || defaultSettings.namingScheme;
    updateNamingPreview();
    setTimeout(() => namingInput.focus(), 0);
  }
}

settingsTabButtons.forEach(btn => {
  btn.addEventListener('click', () => {
    if (btn.dataset.settingsTab) {
      setSettingsPanel(btn.dataset.settingsTab);
    }
  });
});

setSettingsPanel(activeSettingsPanel);

function updateHeader() {
  if (activeTab === TAB_FOLDERS) {
    const title = folderTitleFor(currentFolder);
    albumTitleEl.textContent = title;
    emptyAlbumLabel.textContent = title;
    if (photosHeadingEl) photosHeadingEl.textContent = 'Photos';
  } else {
    if (currentAlbumId) {
      const title = albumTitleFor(currentAlbumId);
      albumTitleEl.textContent = title;
      emptyAlbumLabel.textContent = title;
      if (photosHeadingEl) photosHeadingEl.textContent = title;
    } else {
      albumTitleEl.textContent = 'Photos';
      emptyAlbumLabel.textContent = 'Photos';
      if (photosHeadingEl) photosHeadingEl.textContent = 'Photos';
    }
  }
  updateBackButton();
}

function collectDescendantFolderIds(rootId) {
  const result = [];
  const stack = [rootId];
  while (stack.length) {
    const id = stack.pop();
    result.push(id);
    const children = folders.filter(folder => folder.parentId === id);
    children.forEach(child => stack.push(child.id));
  }
  return result;
}

async function deleteFoldersByIds(ids) {
  const folderSet = new Set();
  ids.forEach(id => {
    const chain = collectDescendantFolderIds(id);
    chain.forEach(value => folderSet.add(value));
  });
  if (!folderSet.size) return;
  const mediaToDelete = photoCache.filter(item => typeof item.folderId === 'number' && folderSet.has(item.folderId));
  for (const media of mediaToDelete) {
    await idbDelete(db, STORE, media.id);
  }
  for (const id of folderSet) {
    await idbDelete(db, FOLDER_STORE, id);
  }
  let prefsChanged = false;
  folderSet.forEach(id => {
    if (clearFolderViewMode(id)) prefsChanged = true;
  });
  if (prefsChanged) saveSettings();
}

async function deleteAlbumsByIds(ids) {
  for (const id of ids) {
    const members = albumMembership.get(id) || new Set();
    for (const photoId of members) {
      await idbDelete(db, COLLECTION_ITEMS_STORE, `${id}-${photoId}`);
    }
    await idbDelete(db, COLLECTION_STORE, id);
  }
  ids.forEach(id => albumMembership.delete(id));
  if (ids.includes(currentAlbumId)) currentAlbumId = null;
  await loadCollections();
  renderAlbumGrid();
  renderGallery();
  updateHeader();
}

function gatherAlbumPhotoIds(set = selectedAlbums) {
  const combined = new Set();
  set.forEach(albumId => {
    const members = albumMembership.get(albumId);
    if (members) members.forEach(id => combined.add(id));
  });
  return combined;
}

async function copyAlbumsToFolderSelected() {
  if (!selectedAlbums.size) return alert('Select albums first.');
  const targetFolder = await pickFolderDestination({ title: 'Copy to folder' });
  if (targetFolder === undefined) return;
  const photoIds = gatherAlbumPhotoIds();
  if (!photoIds.size) return alert('Selected albums do not contain media.');
  const nameSet = buildNameSetForFolder(targetFolder);
  for (const photoId of photoIds) {
    const photo = photoCache.find(item => item.id === photoId);
    if (!photo) continue;
    const newName = nextCopyName(photo.name, targetFolder, nameSet);
    const entry = {
      blob: photo.blob,
      name: newName,
      type: photo.type,
      created: Date.now(),
      captured: photo.captured,
      width: photo.width,
      height: photo.height,
      duration: photo.duration,
      kind: photo.kind,
      size: photo.size,
      preview: photo.preview,
      folderId: targetFolder,
      originalName: photo.originalName || photo.name,
      previewBlob: photo.previewBlob || null,
      previewWidth: photo.previewWidth || 0,
      previewHeight: photo.previewHeight || 0
    };
    await idbAdd(db, STORE, entry);
  }
  await refreshGallery();
  selectedAlbums.clear();
  toggleSelectionMode(false);
  alert(`Copied ${photoIds.size} file(s) into ${typeof targetFolder === 'number' ? folderTitleFor(targetFolder) : 'Drive'}.`);
}

async function copyAlbumsToAlbumSelected() {
  if (!selectedAlbums.size) return alert('Select albums first.');
  const dest = await pickAlbumDestination();
  if (!dest) return;
  const targetAlbum = Number(dest);
  const photoIds = gatherAlbumPhotoIds();
  if (!photoIds.size) return alert('Selected albums do not contain media.');
  const membership = albumMembership.get(targetAlbum) || new Set();
  let added = 0;
  for (const photoId of photoIds) {
    if (membership.has(photoId)) continue;
    const entry = { id: `${targetAlbum}-${photoId}`, albumId: targetAlbum, photoId, created: Date.now() };
    await idbAdd(db, COLLECTION_ITEMS_STORE, entry);
    if (!albumMembership.has(targetAlbum)) albumMembership.set(targetAlbum, new Set());
    albumMembership.get(targetAlbum).add(photoId);
    added++;
  }
  if (!added) {
    alert('All media from the selected albums already exist in that album.');
  } else {
    alert(`Copied ${added} item(s) into the destination album.`);
  }
  await loadCollections();
  if (currentAlbumId === targetAlbum) renderGallery();
  selectedAlbums.clear();
  toggleSelectionMode(false);
}

function formatCountLabel(count) {
  if (count === 0) return 'Empty';
  return count === 1 ? '1 item' : `${count} items`;
}

function getFolderPreviewMedia(folderId) {
  const target = folderId ?? null;
  let latest = null;
  for (const item of photoCache) {
    if ((item.folderId ?? null) !== target) continue;
    if (!latest || item.created > latest.created) latest = item;
  }
  return latest;
}

function getFolderItemCount(folderId) {
  const target = folderId ?? null;
  return photoCache.reduce((count, item) => ((item.folderId ?? null) === target ? count + 1 : count), 0);
}

function buildFolderPickerOption(folderId, label) {
  const count = getFolderItemCount(folderId);
  const subtitle = folderId == null ? `Top level â€¢ ${formatCountLabel(count)}` : formatCountLabel(count);
  const previewItem = getFolderPreviewMedia(folderId);
  return {
    label,
    value: folderId,
    previewMedia: buildPickerPreviewPayload(previewItem),
    icon: 'icons/folder.png',
    subtitle
  };
}

function normalizeFolderValue(value) {
  if (value === SPECIAL_ALL || value === SPECIAL_UNSORTED || value == null) return null;
  if (typeof value === 'number') return value;
  const parsed = Number(value);
  return Number.isFinite(parsed) ? parsed : null;
}

async function pickFolderDestination(opts = {}) {
  const excludeSet = new Set();
  (opts.exclude || []).forEach((val) => {
    excludeSet.add(normalizeFolderValue(val));
  });
  const options = [];
  if (!excludeSet.has(null)) {
    options.push(buildFolderPickerOption(null, 'Drive (root)'));
  }
  folders.forEach(folder => {
    if (excludeSet.has(folder.id)) return;
    options.push(buildFolderPickerOption(folder.id, folder.name));
  });
  const title = opts.title || 'Move to folder';
  return openListPicker({ title, items: options });
}

function getAlbumPreviewMedia(albumId) {
  const membership = albumMembership.get(albumId);
  if (!membership || !membership.size) return null;
  let latest = null;
  for (const item of photoCache) {
    if (!membership.has(item.id)) continue;
    if (!latest || item.created > latest.created) latest = item;
  }
  return latest;
}

function buildAlbumPickerOption(album) {
  const membership = albumMembership.get(album.id);
  const count = membership ? membership.size : 0;
  const previewItem = getAlbumPreviewMedia(album.id);
  return {
    label: album.name,
    value: album.id,
    previewMedia: buildPickerPreviewPayload(previewItem),
    icon: 'icons/gallery.png',
    subtitle: formatCountLabel(count)
  };
}

async function pickAlbumDestination() {
  if (!albums.length) {
    alert('Create an album first.');
    return undefined;
  }
  const options = albums.map(buildAlbumPickerOption);
  return openListPicker({ title: 'Choose album', items: options });
}

function getSelectedMediaItems() {
  const list = [];
  selectedMedia.forEach((id) => {
    const found = photoCache.find(item => item.id === id);
    if (found) list.push(found);
  });
  return list;
}

function updateSelectionChrome() {
  if (selectionActionsEl) {
    selectionActionsEl.classList.toggle('hidden', !selectionMode);
  }
  if (bottomTabsEl) {
    bottomTabsEl.classList.toggle('action-mode', selectionMode);
  }
  const isAlbumGrid = activeTab === TAB_ALBUMS && !currentAlbumId;
  const hasMediaSelection = selectedMedia.size > 0 || selectedFolders.size > 0;
  const hasAlbumSelection = isAlbumGrid && selectedAlbums.size > 0;
  mediaSelectionGroup?.classList.toggle('hidden', isAlbumGrid);
  albumSelectionGroup?.classList.toggle('hidden', !isAlbumGrid);
  selectionActionButtons.forEach(btn => {
    if (isAlbumGrid) {
      btn.disabled = btn.dataset.bulk !== 'delete' || !hasAlbumSelection;
    } else {
      btn.disabled = !hasMediaSelection;
    }
  });
  if (albumSelectionGroup) {
    if (copyAlbumsToFolderBtn) copyAlbumsToFolderBtn.disabled = !hasAlbumSelection;
    if (copyAlbumsToAlbumBtn) copyAlbumsToAlbumBtn.disabled = !hasAlbumSelection;
    if (deleteAlbumsBtn) deleteAlbumsBtn.disabled = !hasAlbumSelection;
  }
  updateSelectionIndicators();
  syncSelectionContainers();
}

async function handleBulkAction(action) {
  switch (action) {
    case 'move':
      await bulkMoveSelected();
      break;
    case 'copy':
      await bulkCopySelected();
      break;
    case 'delete':
      await bulkDeleteSelected();
      break;
    case 'album':
      await bulkAddToAlbumSelected();
      break;
    default:
      break;
  }
}

async function bulkMoveSelected() {
  const items = getSelectedMediaItems();
  if (!items.length) return alert('Select media first.');
  const targetFolder = await pickFolderDestination({ title: 'Move to folder', exclude: [currentFolder] });
  if (targetFolder === undefined) return;
  await Promise.all(items.map(item => idbPut(db, STORE, { ...item, folderId: targetFolder })));
  selectedMedia.clear();
  await refreshGallery();
  toggleSelectionMode(false);
}

async function bulkCopySelected() {
  const items = getSelectedMediaItems();
  if (!items.length) return alert('Select media first.');
  const targetFolder = await pickFolderDestination({ title: 'Copy to folder', exclude: [currentFolder] });
  if (targetFolder === undefined) return;
  const nameSet = buildNameSetForFolder(targetFolder);
  for (const item of items) {
    const newName = nextCopyName(item.name, targetFolder, nameSet);
    const clone = {
      blob: item.blob,
      name: newName,
      type: item.type,
      created: Date.now(),
      captured: item.captured,
      width: item.width,
      height: item.height,
      duration: item.duration,
      kind: item.kind,
      size: item.size,
      preview: item.preview,
      folderId: targetFolder,
      originalName: item.originalName || item.name,
      previewBlob: item.previewBlob || null,
      previewWidth: item.previewWidth || 0,
      previewHeight: item.previewHeight || 0
    };
    await idbAdd(db, STORE, clone);
  }
  selectedMedia.clear();
  await refreshGallery();
  toggleSelectionMode(false);
}

async function bulkDeleteSelected() {
  const items = getSelectedMediaItems();
  const folderIds = Array.from(selectedFolders);
  const albumIds = Array.from(selectedAlbums);
  if (!items.length && !folderIds.length && !albumIds.length) return alert('Select something to delete.');
  const total = items.length + folderIds.length + albumIds.length;
  if (!confirm(`Delete ${total} selected item(s)? This cannot be undone.`)) return;
  const mediaIds = items.map(item => item.id);
  for (const item of items) {
    await idbDelete(db, STORE, item.id);
  }
  if (mediaIds.length) {
    await removeMediaFromAlbums(mediaIds);
  }
  if (folderIds.length) {
    await deleteFoldersByIds(folderIds);
  }
  if (albumIds.length) {
    await deleteAlbumsByIds(albumIds);
  }
  selectedMedia.clear();
  selectedFolders.clear();
  selectedAlbums.clear();
  await loadFolders();
  await refreshGallery();
  toggleSelectionMode(false);
}

async function bulkAddToAlbumSelected() {
  const items = getSelectedMediaItems();
  if (!items.length) return alert('Select media first.');
  const choice = await pickAlbumDestination();
  if (choice === undefined || choice === null) return;
  const albumId = Number(choice);
  if (!Number.isFinite(albumId)) return;
  const membership = albumMembership.get(albumId) || new Set();
  for (const item of items) {
    if (membership.has(item.id)) continue;
    const entry = { id: `${albumId}-${item.id}`, albumId, photoId: item.id, created: Date.now() };
    try {
      await idbAdd(db, COLLECTION_ITEMS_STORE, entry);
      if (!albumMembership.has(albumId)) albumMembership.set(albumId, new Set());
      albumMembership.get(albumId).add(item.id);
    } catch {
      // ignore duplicates
    }
  }
  selectedMedia.clear();
  await loadCollections();
  toggleSelectionMode(false);
  alert('Added to album.');
}

async function handleDeleteAlbum() {
  if (!currentAlbumId) {
    alert('Open an album first.');
    return;
  }
  const albumId = currentAlbumId;
  const album = albums.find(a => a.id === albumId);
  const name = album?.name || 'Album';
  if (!confirm(`Delete "${name}"? This removes the album but keeps all media intact.`)) return;
  const members = albumMembership.get(albumId) || new Set();
  for (const photoId of members) {
    const key = `${albumId}-${photoId}`;
    await idbDelete(db, COLLECTION_ITEMS_STORE, key);
  }
  await idbDelete(db, COLLECTION_STORE, albumId);
  currentAlbumId = null;
  await loadCollections();
  renderAlbumGrid();
  renderGallery();
  updateHeader();
  alert('Album deleted.');
}

function updateBackButton() {
  if (!driveBackBtn) return;
  const showBack = activeTab === TAB_FOLDERS && typeof currentFolder === 'number';
  driveBackBtn.classList.toggle('hidden', !showBack);
}

function cloneViewPrefs(source) {
  return {
    folders: { ...(source?.folders || {}) },
    albumGrid: source?.albumGrid === 'list' ? 'list' : 'grid'
  };
}

function loadSettings() {
  try {
    const raw = JSON.parse(localStorage.getItem(SETTINGS_KEY) || '{}');
    const merged = { ...defaultSettings, ...raw };
    merged.viewPrefs = cloneViewPrefs(raw.viewPrefs || defaultSettings.viewPrefs || {});
    return merged;
  } catch {
    return { ...defaultSettings, viewPrefs: cloneViewPrefs(defaultSettings.viewPrefs || {}) };
  }
}

function saveSettings() {
  try {
    localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
  } catch (err) {
    console.warn('Unable to persist settings', err);
  }
}

function ensureViewPrefsShape(obj = settings) {
  if (!obj) obj = settings;
  if (!obj.viewPrefs || typeof obj.viewPrefs !== 'object') obj.viewPrefs = {};
  const prefs = obj.viewPrefs;
  if (!prefs.folders || typeof prefs.folders !== 'object') prefs.folders = {};
  if (prefs.albumGrid !== 'list' && prefs.albumGrid !== 'grid') prefs.albumGrid = 'grid';
  return prefs;
}

function getFolderViewKey(folderId = currentFolder) {
  if (folderId === SPECIAL_ALL || folderId === SPECIAL_UNSORTED || folderId == null) return 'root';
  if (typeof folderId === 'number') return String(folderId);
  return 'root';
}

function getFolderViewMode(folderId = currentFolder) {
  const prefs = ensureViewPrefsShape();
  const key = getFolderViewKey(folderId);
  const stored = prefs.folders[key];
  if (stored === 'list' || stored === 'grid') return stored;
  return key === 'root' ? 'list' : 'grid';
}

function setFolderViewMode(folderId, mode) {
  const normalized = mode === 'list' ? 'list' : 'grid';
  const prefs = ensureViewPrefsShape();
  const key = getFolderViewKey(folderId);
  if (prefs.folders[key] === normalized) return;
  prefs.folders[key] = normalized;
  saveSettings();
}

function clearFolderViewMode(folderId) {
  const prefs = ensureViewPrefsShape();
  const key = getFolderViewKey(folderId);
  if (prefs.folders[key]) {
    delete prefs.folders[key];
    return true;
  }
  return false;
}

function updateNamingPreview() {
  if (!namingPreview) return;
  const fakeFile = { name: 'IMG_1234.jpg', type: 'image/jpeg', lastModified: Date.now() };
  const template = namingInput?.value || settings.namingScheme;
  namingPreview.textContent = generateFileName(fakeFile, true, template);
}

namingInput?.addEventListener('input', updateNamingPreview);
tokenButtons?.forEach(btn => {
  btn.addEventListener('click', () => {
    const token = btn.dataset.token;
    if (!token || !namingInput) return;
    const start = namingInput.selectionStart ?? namingInput.value.length;
    const end = namingInput.selectionEnd ?? start;
    const value = namingInput.value;
    namingInput.value = value.slice(0, start) + token + value.slice(end);
    const cursor = start + token.length;
    requestAnimationFrame(() => {
      namingInput.focus();
      namingInput.setSelectionRange(cursor, cursor);
    });
    updateNamingPreview();
  });
});

uploadSettingsForm?.addEventListener('submit', (e) => {
  e.preventDefault();
  const template = namingInput?.value?.trim() || defaultSettings.namingScheme;
  settings.namingScheme = template;
  saveSettings();
  updateNamingPreview();
  const submitBtn = uploadSettingsForm.querySelector('button[type="submit"]');
  if (submitBtn) {
    const original = submitBtn.textContent;
    submitBtn.disabled = true;
    submitBtn.textContent = 'Saved';
    setTimeout(() => {
      submitBtn.disabled = false;
      submitBtn.textContent = original;
    }, 1200);
  }
});

albumCancel?.addEventListener('click', closeModal);
modal?.addEventListener('click', (e) => {
  if (e.target === modal) closeModal();
});

albumForm?.addEventListener('submit', async (e) => {
  e.preventDefault();
  const name = albumInput.value.trim();
  if (!name) return;
  if (modalContext === 'folder') {
    const id = await idbAdd(db, FOLDER_STORE, { name, created: Date.now(), parentId: typeof currentFolder === 'number' ? currentFolder : null });
    closeModal();
    await loadFolders();
  } else {
    const id = await idbAdd(db, COLLECTION_STORE, { name, created: Date.now() });
    closeModal();
    await loadCollections();
    setActiveAlbum(Number(id));
  }
});

function openCreateModal(type) {
  modalContext = type;
  albumModalTitle.textContent = type === 'folder' ? 'Create a new folder' : 'Create a new album';
  albumInput.placeholder = type === 'folder' ? 'e.g. Family' : 'e.g. Favorites';
  modal.classList.remove('hidden');
  albumInput.value = '';
  setTimeout(() => albumInput.focus(), 10);
}

function closeModal() {
  modal.classList.add('hidden');
}

updateNamingPreview();
updateSelectionChrome();

if (driveSearchInput) {
  driveSearchInput.addEventListener('input', (e) => {
    driveSearchTerm = (e.target.value || '').toLowerCase();
    renderGallery();
  });
}

function resetDriveSearch(triggerInput = false) {
  driveSearchTerm = '';
  if (driveSearchInput) {
    driveSearchInput.value = '';
    if (triggerInput) {
      driveSearchInput.dispatchEvent(new Event('input', { bubbles: true }));
      return;
    }
  }
  renderGallery();
}

primaryAddBtn?.addEventListener('click', (e) => {
  e.stopPropagation();
  toggleMenu(addMenu, primaryAddBtn);
});

moreActionsBtn?.addEventListener('click', (e) => {
  e.stopPropagation();
  toggleMenu(moreMenu, moreActionsBtn);
});

albumMoreBtn?.addEventListener('click', (e) => {
  e.stopPropagation();
  if (albumMoreBtn.classList.contains('hidden') || albumMoreBtn.classList.contains('disabled')) return;
  albumMoreMenu?.querySelectorAll('[data-album-target="album"]').forEach(btn => {
    btn.classList.toggle('hidden', !!currentAlbumId);
  });
  albumMoreMenu?.querySelectorAll('[data-album-target="media"]').forEach(btn => {
    btn.classList.toggle('hidden', !currentAlbumId);
  });
  albumMoreMenu?.querySelectorAll('.album-grid-action').forEach(btn => {
    btn.classList.toggle('hidden', !!currentAlbumId);
  });
  toggleMenu(albumMoreMenu, albumMoreBtn);
});

addMenu?.addEventListener('click', (e) => {
  const button = e.target.closest('button[data-add]');
  if (!button) return;
  handleAddAction(button.dataset.add);
  closeMenus();
});

moreMenu?.addEventListener('click', (e) => {
  const targetBtn = e.target.closest('button');
  if (!targetBtn) return;
  if (targetBtn.dataset.sort) {
    handleSortSelection(targetBtn.dataset.sort);
    closeMenus();
    return;
  }
  if (targetBtn.dataset.view) {
    handleViewChange(targetBtn.dataset.view);
    closeMenus();
    return;
  }
  if (targetBtn.dataset.action === 'select') {
    toggleSelectionMode();
    closeMenus();
    return;
  }
});

albumMoreMenu?.addEventListener('click', (e) => {
  const targetBtn = e.target.closest('button[data-album-action]');
  if (!targetBtn) return;
  if (targetBtn.dataset.albumAction === 'media-select') {
    if (currentAlbumId) {
      toggleSelectionMode();
    } else {
      alert('Enter an album to select media. Use the Select option while on the grid to select albums.');
    }
    closeMenus();
    return;
  }
  if (targetBtn.dataset.albumAction === 'album-select') {
    if (currentAlbumId) {
      alert('Return to the album grid to select multiple albums.');
    } else {
      toggleSelectionMode();
    }
    closeMenus();
    return;
  }
  if (targetBtn.dataset.albumSort) {
    handleAlbumSort(targetBtn.dataset.albumSort);
    closeMenus();
    return;
  }
  if (targetBtn.dataset.albumView) {
    handleAlbumView(targetBtn.dataset.albumView);
    closeMenus();
    return;
  }
  if (targetBtn.dataset.albumAction === 'delete') {
    handleDeleteAlbum();
    closeMenus();
  }
});

selectionActionsEl?.addEventListener('click', async (e) => {
  const btn = e.target.closest('button[data-bulk]');
  if (!btn || btn.disabled) return;
  await handleBulkAction(btn.dataset.bulk);
});

selectionCancelBtn?.addEventListener('click', () => {
  toggleSelectionMode(false);
});

selectionAllBtn?.addEventListener('click', () => {
  selectAllVisible();
});

copyAlbumsToFolderBtn?.addEventListener('click', async () => {
  await copyAlbumsToFolderSelected();
});

copyAlbumsToAlbumBtn?.addEventListener('click', async () => {
  await copyAlbumsToAlbumSelected();
});

deleteAlbumsBtn?.addEventListener('click', async () => {
  if (!selectedAlbums.size) return alert('Select albums first.');
  if (!confirm(`Delete ${selectedAlbums.size} album(s)? This cannot be undone.`)) return;
  await deleteAlbumsByIds(Array.from(selectedAlbums));
  selectedAlbums.clear();
  toggleSelectionMode(false);
});

document.addEventListener('click', (e) => {
  if (!e.target.closest('.dropdown')) closeMenus();
});

driveBackBtn?.addEventListener('click', () => {
  if (selectionMode) toggleSelectionMode(false);
  if (currentFolder === SPECIAL_ALL) return;
  const parentId = getFolderParentId(currentFolder);
  if (parentId == null) {
    setActiveFolder(SPECIAL_ALL);
  } else {
    setActiveFolder(parentId);
  }
});

albumBackBtn?.addEventListener('click', () => {
  if (selectionMode) toggleSelectionMode(false);
  setActiveAlbum(null);
});

const DB_READY = (async () => {
  while (!db) await new Promise(r => setTimeout(r, 50));
})();

input.addEventListener('change', async (e) => {
  await addFiles(e.target.files);
  input.value = '';
});

async function addFiles(fileList) {
  if (!fileList || !fileList.length) return;
  await DB_READY;
  const targetFolder = typeof currentFolder === 'number' ? currentFolder : null;
  const arr = Array.from(fileList).filter(isSupportedFile);
  if (!arr.length) return;
  for (const file of arr) {
    const arrayBuf = await file.arrayBuffer();
    const blob = new Blob([arrayBuf], { type: file.type || 'image/jpeg' });
    const created = Date.now();
    const captured = file.lastModified ? Number(file.lastModified) : created;
    const meta = await getMediaMeta(blob, blob.type || file.type || 'image/jpeg');
    const safeName = generateFileName({
      name: file.name,
      type: file.type,
      lastModified: created
    });
    const previewData = await generatePreviewBlob(blob, meta.kind, blob.type || file.type);
    await idbAdd(db, STORE, {
      blob,
      name: safeName,
      type: blob.type || file.type || 'image/jpeg',
      created,
      captured,
      width: meta.width || 0,
      height: meta.height || 0,
      duration: meta.duration || 0,
      kind: meta.kind || 'image',
      size: blob.size || arrayBuf.byteLength || 0,
      folderId: targetFolder,
      originalName: file.name || safeName,
      previewBlob: previewData?.blob || null,
      previewWidth: previewData?.width || 0,
      previewHeight: previewData?.height || 0
    });
  }
  await refreshGallery();
  resetDriveSearch(true);
}

async function addInlineMedia({ name, blob, type }) {
  await DB_READY;
  const created = Date.now();
  const pseudoFile = { name, type, lastModified: created };
  const safeName = generateFileName(pseudoFile);
  let meta = { width: 0, height: 0, duration: 0, kind: type.startsWith('video/') ? 'video' : type.startsWith('image/') ? 'image' : 'text' };
  let previewData = null;
  if (meta.kind === 'image' || meta.kind === 'video') {
    meta = await getMediaMeta(blob, type);
    previewData = await generatePreviewBlob(blob, meta.kind, type);
  }
  const textPreview = type === 'text/plain' ? (await blob.text()).slice(0, 200) : '';
  await idbAdd(db, STORE, {
    blob,
    name: safeName,
    type,
    created,
    captured: created,
    width: meta.width || 0,
    height: meta.height || 0,
    duration: meta.duration || 0,
    kind: meta.kind,
    size: blob.size || 0,
    preview: textPreview,
    folderId: typeof currentFolder === 'number' ? currentFolder : null,
    originalName: name,
    previewBlob: previewData?.blob || null,
    previewWidth: previewData?.width || 0,
    previewHeight: previewData?.height || 0
  });
  await refreshGallery();
  resetDriveSearch(true);
}

function isSupportedFile(file) {
  const type = file.type || '';
  if (type.startsWith('image/') || type.startsWith('video/')) return true;
  const name = file.name?.toLowerCase() || '';
  return /(png|jpg|jpeg|gif|webp|mp4|mov|webm)$/i.test(name);
}

function imgSize(url) {
  return new Promise((res, rej) => { const i = new Image(); i.onload = ()=>res({width:i.naturalWidth, height:i.naturalHeight}); i.onerror=rej; i.src=url; });
}

function videoMeta(url) {
  return new Promise((resolve, reject) => {
    const video = document.createElement('video');
    video.preload = 'metadata';
    video.muted = true;
    video.onloadedmetadata = () => {
      resolve({
        width: video.videoWidth || 0,
        height: video.videoHeight || 0,
        duration: video.duration || 0
      });
      video.remove();
    };
    video.onerror = (err) => { video.remove(); reject(err || new Error('Video metadata error')); };
    video.src = url;
  });
}

async function getMediaMeta(blob, type) {
  const url = URL.createObjectURL(blob);
  try {
    const mime = type || 'image/jpeg';
    if (mime.startsWith('video/')) {
      try {
        const meta = await videoMeta(url);
        return { ...meta, kind: 'video' };
      } catch {
        return { width: 0, height: 0, duration: 0, kind: 'video' };
      }
    }
    const meta = await imgSize(url);
    return { width: meta.width, height: meta.height, duration: 0, kind: 'image' };
  } finally {
    URL.revokeObjectURL(url);
  }
}

function mimeToExtension(type = '') {
  if (type.includes('jpeg') || type.includes('jpg')) return '.jpg';
  if (type.includes('png')) return '.png';
  if (type.includes('gif')) return '.gif';
  if (type.includes('webp')) return '.webp';
  if (type.includes('mp4')) return '.mp4';
  if (type.includes('quicktime')) return '.mov';
  if (type.includes('webm')) return '.webm';
  return '';
}

const PREVIEW_MAX_DIMENSION = 512;

function clearMediaUrlCache() {
  mediaUrlCache.forEach((url) => URL.revokeObjectURL(url));
  mediaUrlCache.clear();
}

function mediaCacheKey(item, variant) {
  if (!item || item.id == null) return null;
  return `${item.id}:${variant}`;
}

function getThumbnailAsset(item) {
  if (!item || item.id == null) return null;
  const key = mediaCacheKey(item, 'thumb');
  if (!key) return null;
  if (!item.previewBlob && item.kind !== 'text') {
    schedulePreviewGeneration(item);
  }
  if (mediaUrlCache.has(key)) {
    return { key, url: mediaUrlCache.get(key) };
  }
  const blobSource = item.previewBlob || (item.kind === 'text' ? null : item.blob);
  if (!blobSource) return null;
  const url = URL.createObjectURL(blobSource);
  mediaUrlCache.set(key, url);
  return { key, url };
}

function schedulePreviewGeneration(item) {
  if (!item || item.id == null || pendingPreviewIds.has(item.id)) return;
  if (item.previewBlob || item.kind === 'text') return;
  pendingPreviewIds.add(item.id);
  (async () => {
    try {
      const previewData = await generatePreviewBlob(item.blob, item.kind, item.type);
      if (previewData?.blob) {
        item.previewBlob = previewData.blob;
        item.previewWidth = previewData.width || 0;
        item.previewHeight = previewData.height || 0;
        await DB_READY;
        await idbPut(db, STORE, item);
        const key = mediaCacheKey(item, 'thumb');
        if (key && mediaUrlCache.has(key)) {
          const oldUrl = mediaUrlCache.get(key);
          mediaUrlCache.delete(key);
          if (oldUrl) URL.revokeObjectURL(oldUrl);
        }
        const asset = getThumbnailAsset(item);
        if (asset) updateThumbnailElements(asset.key, asset.url);
      }
    } catch (err) {
      console.warn('Deferred preview generation failed', err);
    } finally {
      pendingPreviewIds.delete(item.id);
    }
  })();
}

function updateThumbnailElements(key, url) {
  if (!key || !url) return;
  document.querySelectorAll(`img[data-thumb-key=\"${key}\"]`).forEach((img) => {
    if (img.src !== url) {
      img.src = url;
    }
  });
}

function buildPickerPreviewPayload(item) {
  if (!item) return null;
  const blob = item.previewBlob || (item.kind === 'text' ? null : item.blob);
  if (!blob) {
    return item.kind === 'text'
      ? { kind: 'text', preview: item.preview, name: item.name }
      : null;
  }
  return {
    blob,
    kind: item.kind,
    type: item.previewBlob ? 'image/webp' : (item.type || 'image/jpeg'),
    preview: item.preview,
    name: item.name
  };
}

async function generatePreviewBlob(blob, kind, mime) {
  if (!blob) return null;
  const type = mime || blob.type || '';
  const normalizedKind = kind || (type.startsWith('video/') ? 'video' : type.startsWith('image/') ? 'image' : '');
  try {
    if (normalizedKind === 'image') {
      return await createImagePreviewBlob(blob);
    }
    if (normalizedKind === 'video') {
      return await createVideoPreviewBlob(blob);
    }
  } catch (err) {
    console.warn('Preview generation failed', err);
  }
  return null;
}

async function createImagePreviewBlob(blob, maxDim = PREVIEW_MAX_DIMENSION) {
  return new Promise((resolve) => {
    const img = new Image();
    const url = URL.createObjectURL(blob);
    img.onload = async () => {
      const scale = Math.min(1, maxDim / Math.max(img.width || maxDim, img.height || maxDim));
      const width = Math.max(1, Math.round((img.width || maxDim) * scale));
      const height = Math.max(1, Math.round((img.height || maxDim) * scale));
      const canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext('2d');
      if (!ctx) {
        URL.revokeObjectURL(url);
        resolve(null);
        return;
      }
      ctx.drawImage(img, 0, 0, width, height);
      const previewBlob = await canvasToBlob(canvas, 'image/webp', 0.82);
      URL.revokeObjectURL(url);
      resolve(previewBlob ? { blob: previewBlob, width, height } : null);
    };
    img.onerror = () => {
      URL.revokeObjectURL(url);
      resolve(null);
    };
    img.src = url;
  });
}

async function createVideoPreviewBlob(blob, maxDim = PREVIEW_MAX_DIMENSION) {
  return new Promise((resolve) => {
    const video = document.createElement('video');
    const url = URL.createObjectURL(blob);
    let resolved = false;
    const cleanup = () => {
      URL.revokeObjectURL(url);
      video.removeAttribute('src');
      video.load();
      video.remove();
    };
    const finish = (payload) => {
      if (resolved) return;
      resolved = true;
      cleanup();
      resolve(payload);
    };
    video.muted = true;
    video.playsInline = true;
    video.preload = 'metadata';
    video.onloadeddata = async () => {
      try {
        const width = video.videoWidth || maxDim;
        const height = video.videoHeight || maxDim;
        const scale = Math.min(1, maxDim / Math.max(width, height));
        const canvasWidth = Math.max(1, Math.round(width * scale));
        const canvasHeight = Math.max(1, Math.round(height * scale));
        const canvas = document.createElement('canvas');
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
        const ctx = canvas.getContext('2d');
        if (!ctx) {
          finish(null);
          return;
        }
        ctx.drawImage(video, 0, 0, canvasWidth, canvasHeight);
        const previewBlob = await canvasToBlob(canvas, 'image/webp', 0.8);
        finish(previewBlob ? { blob: previewBlob, width: canvasWidth, height: canvasHeight } : null);
      } catch (err) {
        console.warn('Video preview capture failed', err);
        finish(null);
      }
    };
    video.onerror = () => finish(null);
    video.src = url;
  });
}

function canvasToBlob(canvas, type = 'image/webp', quality = 0.82) {
  return new Promise((resolve) => {
    if (canvas.toBlob) {
      canvas.toBlob((blob) => resolve(blob), type, quality);
      return;
    }
    const dataUrl = canvas.toDataURL(type, quality);
    resolve(dataUrlToBlob(dataUrl));
  });
}

function dataUrlToBlob(dataUrl) {
  if (!dataUrl) return null;
  const [header, data] = dataUrl.split(',');
  const mimeMatch = header?.match(/:(.*?);/);
  const mime = mimeMatch ? mimeMatch[1] : 'image/png';
  const binary = atob(data || '');
  const len = binary.length;
  const array = new Uint8Array(len);
  for (let i = 0; i < len; i++) {
    array[i] = binary.charCodeAt(i);
  }
  return new Blob([array], { type: mime });
}


function sanitizeSegment(value) {
  return (value || '').toLowerCase().replace(/[^\w-]+/g, '-').replace(/-+/g, '-').replace(/^-+|-+$/g, '');
}

function cleanFileName(value, fallback = 'media') {
  const cleaned = (value || '').replace(/[<>:"/\\|?*]+/g, '-').replace(/\s+/g, ' ').trim();
  return cleaned || fallback || 'media';
}

function formatTimestampName(input = Date.now()) {
  const date = input instanceof Date ? input : new Date(input || Date.now());
  const pad = (n) => String(n).padStart(2, '0');
  return `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())} ${pad(date.getHours())}.${pad(date.getMinutes())}.${pad(date.getSeconds())}`;
}

function splitNameParts(name = '') {
  const dot = name.lastIndexOf('.');
  if (dot > 0) {
    return { base: name.slice(0, dot), ext: name.slice(dot) };
  }
  return { base: name, ext: '' };
}

function generateFileName(file, preview = false, templateOverride) {
  const originalFull = file.name || '';
  let { base: originalBase, ext } = splitNameParts(originalFull);
  if (!ext) ext = mimeToExtension(file.type || '');
  if (!originalBase) originalBase = file.type?.startsWith('video/') ? 'video' : 'photo';
  const template = (templateOverride && templateOverride.trim()) || (settings.namingScheme && settings.namingScheme.trim()) || defaultSettings.namingScheme;
  const date = new Date(file.lastModified || Date.now());
  const dateStr = date.toISOString().slice(0, 10);
  const timeStr = date.toTimeString().slice(0, 8).replace(/:/g, '-');
  const timestampHuman = formatTimestampName(date);
  const needsCounter = template.includes('{{counter}}');
  const replacements = {
    original: sanitizeSegment(originalBase) || 'media',
    original_name: originalBase || 'media',
    date: dateStr,
    time: timeStr,
    timestamp: timestampHuman,
    timestamp_human: timestampHuman,
    counter: needsCounter ? String(settings.counter || 1).padStart(3, '0') : ''
  };
  let result = template;
  for (const [token, value] of Object.entries(replacements)) {
    result = result.split(`{{${token}}}`).join(value ?? '');
  }
  result = cleanFileName(result, originalBase || 'media');
  if (needsCounter && !preview) {
    settings.counter = (settings.counter || 1) + 1;
    saveSettings();
  }
  return ext ? `${result}${ext}` : result;
}

function buildNameSetForFolder(folderId) {
  const target = folderId ?? null;
  const nameSet = new Set();
  photoCache.forEach(item => {
    if ((item.folderId ?? null) === target) {
      nameSet.add((item.name || '').toLowerCase());
    }
  });
  return nameSet;
}

function nextCopyName(name, folderId, nameSet) {
  const { base, ext } = splitNameParts(name);
  const safeBase = cleanFileName(base || 'media', 'media');
  const normalizedSet = nameSet || buildNameSetForFolder(folderId);
  let index = 1;
  let candidate;
  do {
    candidate = `${safeBase}_${index}${ext}`;
    index += 1;
  } while (normalizedSet.has(candidate.toLowerCase()));
  normalizedSet.add(candidate.toLowerCase());
  return candidate;
}

function formatDuration(seconds = 0) {
  const total = Math.max(0, Math.round(seconds || 0));
  const hrs = Math.floor(total / 3600);
  const mins = Math.floor((total % 3600) / 60);
  const secs = total % 60;
  const parts = [
    hrs > 0 ? String(hrs) : null,
    hrs > 0 ? String(mins).padStart(2, '0') : String(mins),
    String(secs).padStart(2, '0')
  ].filter(Boolean);
  return parts.join(':');
}

function formatFileSize(bytes = 0) {
  if (!bytes || bytes < 0) return 'â€”';
  const units = ['B', 'KB', 'MB', 'GB', 'TB'];
  let value = bytes;
  let unit = 0;
  while (value >= 1024 && unit < units.length - 1) {
    value /= 1024;
    unit += 1;
  }
  return `${value.toFixed(unit === 0 ? 0 : 1)} ${units[unit]}`;
}

async function refreshGallery() {
  const raw = await idbAll(db, STORE);
  clearMediaUrlCache();
  photoCache = raw.map(item => {
    if (item.folderId == null && item.albumId != null) item.folderId = item.albumId;
    if (item.captured == null) item.captured = item.created;
    if (!item.kind) item.kind = item.type?.startsWith('video/') ? 'video' : 'image';
    if (item.duration == null && item.kind === 'video') item.duration = 0;
    if (item.width == null) item.width = 0;
    if (item.height == null) item.height = 0;
    if (item.size == null) item.size = item.blob?.size || 0;
    if (!('previewWidth' in item)) item.previewWidth = 0;
    if (!('previewHeight' in item)) item.previewHeight = 0;
    if (!('previewBlob' in item)) item.previewBlob = null;
    return item;
  });
  renderFolderList();
  renderGallery();
}

function renderGallery() {
  const isDrive = activeTab === TAB_FOLDERS;
  if (activeTab === TAB_SETTINGS) {
    driveItemsEl.innerHTML = '';
    document.getElementById('emptyState')?.classList.add('hidden');
    albumMediaEl.innerHTML = '';
    albumMediaPanel?.classList.add('hidden');
    albumBackBtn?.classList.add('hidden');
    updateSelectionChrome();
    return;
  }
  const container = isDrive ? driveItemsEl : albumMediaEl;
  if (!container) return;
  const driveEmpty = document.getElementById('emptyState');
  const albumEmpty = albumMediaEmptyEl;

  if (isDrive) {
    container.innerHTML = '';
    driveViewMode = getFolderViewMode(currentFolder);
    container.classList.toggle('folder-list-view', driveViewMode === 'list');
    albumEmpty?.classList.add('hidden');
    const parentId = typeof currentFolder === 'number' ? currentFolder : null;
    const counts = photoCache.reduce((acc, item) => {
      const key = item.folderId ?? null;
      acc[key] = (acc[key] || 0) + 1;
      return acc;
    }, {});
    let childFolders = folders.filter(folder => (folder.parentId ?? null) === (parentId ?? null));
    if (driveSearchTerm) {
      const term = driveSearchTerm.toLowerCase();
      childFolders = childFolders.filter(folder => folder.name.toLowerCase().includes(term));
    }
    childFolders.sort((a, b) => a.name.localeCompare(b.name));
    const visibleFolderSet = new Set(childFolders.map(f => f.id));
    selectedFolders.forEach(id => { if (!visibleFolderSet.has(id)) selectedFolders.delete(id); });
    visibleFolderIds = childFolders.map(folder => folder.id);

    let mediaList = typeof currentFolder === 'number'
      ? photoCache.filter(item => item.folderId === currentFolder)
      : photoCache.filter(item => item.folderId == null);
    if (driveSearchTerm) {
      const term = driveSearchTerm.toLowerCase();
      mediaList = mediaList.filter(item => (item.name || '').toLowerCase().includes(term));
    }
    mediaList = sortPhotos(mediaList);
    currentViewList = mediaList;
    visibleMediaIds = mediaList.map(item => item.id);
    const visibleMediaSet = new Set(visibleMediaIds);
    selectedMedia = new Set([...selectedMedia].filter(id => visibleMediaSet.has(id)));

    if (!childFolders.length && !mediaList.length) {
      if (driveEmpty) {
        driveEmpty.classList.remove('hidden');
        driveEmpty.innerHTML = driveSearchTerm
          ? `No results match "${driveSearchTerm}".`
          : 'No media in <strong>' + emptyAlbumLabel.textContent + '</strong> yet.';
      }
      updateSelectionChrome();
      return;
    }
    driveEmpty?.classList.add('hidden');
    const fragment = document.createDocumentFragment();
    childFolders.forEach(folder => fragment.appendChild(createFolderCard(folder, counts[folder.id] || 0)));
    mediaList.forEach((item, idx) => fragment.appendChild(createMediaTile(item, idx)));
    container.appendChild(fragment);
    updateSelectionChrome();
    return;
  }

  // Album tab
  container.innerHTML = '';
  driveEmpty?.classList.add('hidden');
  const viewingAlbum = !!currentAlbumId;
  albumMediaPanel?.classList.toggle('hidden', !viewingAlbum);
  albumBackBtn?.classList.toggle('hidden', !viewingAlbum);
  if (viewingAlbum) visibleAlbumIds = [];
  if (!viewingAlbum) {
    albumMediaEmptyEl?.classList.add('hidden');
    currentViewList = [];
    visibleFolderIds = [];
    visibleMediaIds = [];
    updateSelectionChrome();
    return;
  }
  const ids = albumMembership.get(currentAlbumId);
  if (!ids || !ids.size) {
    albumMediaEmptyEl?.classList.remove('hidden');
    currentViewList = [];
    visibleFolderIds = [];
    visibleMediaIds = [];
    updateSelectionChrome();
    return;
  }
  visibleFolderIds = [];
  albumMediaEmptyEl?.classList.add('hidden');
  let list = photoCache.filter(item => ids.has(item.id));
  list = sortPhotos(list);
  currentViewList = list;
  visibleMediaIds = list.map(item => item.id);
  albumEmpty?.classList.add('hidden');
  list.forEach((item, idx) => {
    const isVideo = item.kind === 'video' || item.type?.startsWith('video/');
    const isText = item.kind === 'text' || item.type === 'text/plain';
    const card = document.createElement('button');
    card.type = 'button';
    const isSelected = selectedMedia.has(item.id);
    card.className = 'card album-media-card' + (isSelected ? ' selected' : '');
    card.dataset.mediaId = String(item.id);
    const indicator = document.createElement('span');
    indicator.className = 'select-indicator';
    card.appendChild(indicator);
    let mediaEl;
    if (isText) {
      mediaEl = document.createElement('div');
      mediaEl.className = 'text-card';
      mediaEl.textContent = item.preview || item.name || 'Text file';
    } else {
      const asset = getThumbnailAsset(item);
      if (asset) {
        mediaEl = document.createElement('img');
        mediaEl.loading = 'lazy';
        mediaEl.decoding = 'async';
        mediaEl.alt = item.name;
        mediaEl.src = asset.url;
        mediaEl.dataset.thumbKey = asset.key;
      } else {
        mediaEl = document.createElement('div');
        mediaEl.className = 'text-card';
        mediaEl.textContent = item.name || 'Media';
      }
    }
    if (isVideo) {
      const flag = document.createElement('span');
      flag.className = 'media-flag';
      flag.textContent = 'ðŸŽ¬ Video';
      card.appendChild(flag);
    }
    card.appendChild(mediaEl);
    if (albumMediaPanel?.classList.contains('list-view-mode')) {
      const meta = document.createElement('div');
      meta.className = 'meta';
      const label = document.createElement('span');
      label.textContent = new Date(item.created).toLocaleString();
      const chip = document.createElement('span');
      chip.className = 'chip';
      chip.textContent = isVideo ? formatDuration(item.duration) : (isText ? 'Text file' : `${item.width}Ã—${item.height}`);
      meta.append(label, chip);
      card.appendChild(meta);
    }
    card.addEventListener('click', () => {
      if (selectionMode && activeTab === TAB_ALBUMS && currentAlbumId) {
        if (selectedMedia.has(item.id)) {
          selectedMedia.delete(item.id);
          card.classList.remove('selected');
        } else {
          selectedMedia.add(item.id);
          card.classList.add('selected');
        }
        updateSelectionChrome();
        return;
      }
      openViewerAt(idx);
    });
    container.appendChild(card);
  });
  updateSelectionChrome();
}

function sortPhotos(list) {
  const sorted = list.slice();
  sorted.sort((a, b) => {
    switch (mediaSortMode) {
      case 'name-asc':
        return (a.name || '').toLowerCase().localeCompare((b.name || '').toLowerCase());
      case 'name-desc':
        return (b.name || '').toLowerCase().localeCompare((a.name || '').toLowerCase());
      case 'size-asc':
        return (a.size || 0) - (b.size || 0);
      case 'size-desc':
        return (b.size || 0) - (a.size || 0);
      case 'created-asc':
        return (a.created || 0) - (b.created || 0);
      case 'created-desc':
      default:
        return (b.created || 0) - (a.created || 0);
    }
  });
  return sorted;
}


function openViewerAt(index) {
  if (!currentViewList.length) return;
  if (index < 0 || index >= currentViewList.length) return;
  currentViewerIndex = index;
  viewMedia(currentViewList[index]);
}

function getCurrentItem() {
  if (currentViewerIndex < 0) return null;
  return currentViewList[currentViewerIndex] || null;
}

function viewMedia(item) {
  if (viewerUrl) {
    if (!viewerVideo.classList.contains('hidden')) {
      viewerVideo.pause();
      viewerVideo.removeAttribute('src');
      viewerVideo.load();
    }
    URL.revokeObjectURL(viewerUrl);
    viewerUrl = null;
  }
  resetZoom();
  toggleChrome(false);
  const url = URL.createObjectURL(item.blob);
  viewerUrl = url;
  const isVideo = item.kind === 'video' || item.type?.startsWith('video/');
  viewerImg.classList.toggle('hidden', isVideo);
  viewerVideo.classList.toggle('hidden', !isVideo);
  if (isVideo) {
    viewerVideo.src = url;
    viewerVideo.currentTime = 0;
    viewerVideo.muted = true;
    viewerVideo.play().catch(()=>{});
    muteToggle.classList.remove('hidden');
    muteToggle.textContent = 'ðŸ”‡';
  } else {
    viewerImg.src = url;
    viewerImg.alt = item.name;
    muteToggle.classList.add('hidden');
  }
  viewerTitle.textContent = item.name || (isVideo ? 'Video' : 'Photo');
  const captured = new Date(item.captured ?? item.created).toLocaleString();
  const extra = isVideo && item.duration ? ` â€¢ ${formatDuration(item.duration)}` : ` â€¢ ${item.width}Ã—${item.height}`;
  viewerDetails.textContent = `${captured}${extra}`;
  photoViewer.classList.remove('hidden');
}

function navigateViewer(delta) {
  if (currentViewerIndex === -1) return;
  const nextIndex = currentViewerIndex + delta;
  if (nextIndex < 0 || nextIndex >= currentViewList.length) return;
  openViewerAt(nextIndex);
}

function closeViewer() {
  photoViewer.classList.add('hidden');
  viewerImg.src = '';
  viewerImg.classList.remove('hidden');
  viewerVideo.pause();
  viewerVideo.removeAttribute('src');
  viewerVideo.load();
  viewerVideo.classList.add('hidden');
  muteToggle.classList.add('hidden');
  if (viewerUrl) {
    URL.revokeObjectURL(viewerUrl);
    viewerUrl = null;
  }
  currentViewerIndex = -1;
  chromeHidden = false;
  resetZoom();
  clearTimeout(tapTimeout);
  lastTapTime = 0;
}

viewerClose?.addEventListener('click', closeViewer);
photoViewer?.addEventListener('click', (e) => {
  if (e.target === photoViewer) closeViewer();
});

actionMoveFolder?.addEventListener('click', handleMoveToFolder);
actionAddAlbumBtn?.addEventListener('click', handleAddToAlbum);
actionSave?.addEventListener('click', handleSaveMedia);
actionInfo?.addEventListener('click', handleInfo);

muteToggle?.addEventListener('click', () => {
  if (viewerVideo.classList.contains('hidden')) return;
  viewerVideo.muted = !viewerVideo.muted;
  muteToggle.textContent = viewerVideo.muted ? 'ðŸ”‡' : 'ðŸ”Š';
});

viewerMediaEl?.addEventListener('pointerdown', onViewerPointerDown);
viewerMediaEl?.addEventListener('pointermove', onViewerPointerMove);
viewerMediaEl?.addEventListener('pointerup', onViewerPointerUp);
viewerMediaEl?.addEventListener('pointercancel', resetGesture);
viewerMediaEl?.addEventListener('pointerleave', (e) => {
  if (gesture.active && gesture.pointerId === e.pointerId && !gesture.panMode) resetGesture();
});

function toggleChrome(force) {
  chromeHidden = typeof force === 'boolean' ? force : !chromeHidden;
  photoViewer?.classList.toggle('hide-chrome', chromeHidden);
}

function resetZoom() {
  isZoomed = false;
  panX = 0;
  panY = 0;
  applyZoomTransform();
}

function getActiveMediaElement() {
  if (!viewerVideo.classList.contains('hidden')) return viewerVideo;
  return viewerImg;
}

function applyZoomTransform() {
  const target = getActiveMediaElement();
  if (!target) return;
  if (isZoomed) {
    const limit = 200;
    panX = Math.max(Math.min(panX, limit), -limit);
    panY = Math.max(Math.min(panY, limit), -limit);
    target.style.transform = `translate(${panX}px, ${panY}px) scale(2)`;
    target.classList.add('zoomed');
  } else {
    target.style.transform = 'translate(0,0) scale(1)';
    target.classList.remove('zoomed');
  }
}

function toggleZoom(event) {
  const target = getActiveMediaElement();
  if (!target) return;
  isZoomed = !isZoomed;
  if (isZoomed) {
    const rect = target.getBoundingClientRect();
    const originX = ((event?.clientX ?? (rect.left + rect.width / 2)) - rect.left) / rect.width * 100;
    const originY = ((event?.clientY ?? (rect.top + rect.height / 2)) - rect.top) / rect.height * 100;
    target.style.transformOrigin = `${originX}% ${originY}%`;
  } else {
    panX = 0;
    panY = 0;
    target.style.transformOrigin = '50% 50%';
  }
  applyZoomTransform();
}

function handleTap(event) {
  const now = Date.now();
  if (now - lastTapTime < 300) {
    clearTimeout(tapTimeout);
    lastTapTime = 0;
    toggleZoom(event);
  } else {
    lastTapTime = now;
    tapTimeout = setTimeout(() => {
      toggleChrome();
      lastTapTime = 0;
    }, 320);
  }
}

function toggleMenu(menu, button) {
  if (!menu) return;
  const isOpen = menu.classList.contains('show');
  closeMenus();
  if (!isOpen) {
    menu.classList.add('show');
    button?.setAttribute('aria-expanded', 'true');
  }
}

function closeMenus() {
  addMenu?.classList.remove('show');
  moreMenu?.classList.remove('show');
  albumMoreMenu?.classList.remove('show');
  primaryAddBtn?.setAttribute('aria-expanded', 'false');
  moreActionsBtn?.setAttribute('aria-expanded', 'false');
  albumMoreBtn?.setAttribute('aria-expanded', 'false');
}

function handleAddAction(action) {
  switch (action) {
    case 'import':
      triggerFileSelect('');
      break;
    case 'folder':
      openCreateModal('folder');
      break;
    case 'text':
      handleTextFileCreate();
      break;
    default:
      break;
  }
}

function triggerFileSelect(accept) {
  if (!input) return;
  const original = input.accept;
  input.accept = accept || 'image/*,video/*';
  input.click();
  setTimeout(() => { input.accept = original; }, 0);
}

async function handleTextFileCreate() {
  const result = await openTextFileModal('notes.txt');
  if (!result) return;
  const { name, content } = result;
  const blob = new Blob([content], { type: 'text/plain' });
  await addInlineMedia({
    name,
    blob,
    type: 'text/plain'
  });
}

function handleSortSelection(mode) {
  mediaSortMode = mode || 'created-desc';
  renderGallery();
}

function handleViewChange(mode) {
  const next = mode === 'list' ? 'list' : 'grid';
  setFolderViewMode(currentFolder, next);
  driveViewMode = next;
  renderGallery();
}

function toggleSelectionMode(force) {
  const next = typeof force === 'boolean' ? force : !selectionMode;
  if (next === selectionMode) {
    updateSelectionChrome();
    return;
  }
  if (!next) {
    selectedFolders.clear();
    selectedMedia.clear();
    selectedAlbums.clear();
  }
  selectionMode = next;
  updateSelectionChrome();
}

function selectAllVisible() {
  if (activeTab === TAB_ALBUMS && !currentAlbumId) {
    if (!visibleAlbumIds.length) return alert('Nothing to select here.');
    if (!selectionMode) toggleSelectionMode(true);
    selectedAlbums = new Set(visibleAlbumIds);
    updateSelectionChrome();
    return;
  }
  const hasAny = visibleFolderIds.length || visibleMediaIds.length;
  if (!hasAny) {
    alert('Nothing to select here.');
    return;
  }
  if (!selectionMode) {
    toggleSelectionMode(true);
  }
  selectedFolders = new Set(visibleFolderIds);
  selectedMedia = new Set(visibleMediaIds);
  updateSelectionChrome();
}

function handleAlbumSort(mode) {
  albumSortMode = mode || 'name-asc';
  renderAlbumGrid();
}

function handleAlbumView(mode) {
  albumViewMode = mode === 'list' ? 'list' : 'grid';
  const prefs = ensureViewPrefsShape();
  if (prefs.albumGrid !== albumViewMode) {
    prefs.albumGrid = albumViewMode;
    saveSettings();
  }
  renderAlbumGrid();
}

function updateSelectionIndicators() {
  syncDriveSelectionIndicators();
  syncAlbumGridSelectionIndicators();
  syncAlbumMediaSelectionIndicators();
}

function syncDriveSelectionIndicators() {
  if (!driveItemsEl) return;
  driveItemsEl.querySelectorAll('.folder-card[data-folder-id]').forEach((card) => {
    const id = Number(card.dataset.folderId);
    if (!Number.isNaN(id)) {
      card.classList.toggle('selected', selectedFolders.has(id));
    }
  });
  driveItemsEl.querySelectorAll('.media-card[data-media-id]').forEach((card) => {
    const id = Number(card.dataset.mediaId);
    if (!Number.isNaN(id)) {
      card.classList.toggle('selected', selectedMedia.has(id));
    }
  });
}

function syncAlbumGridSelectionIndicators() {
  if (!albumGridEl) return;
  albumGridEl.querySelectorAll('.album-card[data-album-id]').forEach((card) => {
    const id = Number(card.dataset.albumId);
    if (!Number.isNaN(id)) {
      card.classList.toggle('selected', selectedAlbums.has(id));
    }
  });
}

function syncAlbumMediaSelectionIndicators() {
  if (!albumMediaEl) return;
  albumMediaEl.querySelectorAll('.album-media-card[data-media-id]').forEach((card) => {
    const id = Number(card.dataset.mediaId);
    if (!Number.isNaN(id)) {
      card.classList.toggle('selected', selectedMedia.has(id));
    }
  });
}

function syncSelectionContainers() {
  const driveSelecting = selectionMode && activeTab === TAB_FOLDERS;
  const albumGridSelecting = selectionMode && activeTab === TAB_ALBUMS && !currentAlbumId;
  const albumMediaSelecting = selectionMode && activeTab === TAB_ALBUMS && !!currentAlbumId;
  driveShellEl?.classList.toggle('selecting', driveSelecting);
  albumShellEl?.classList.toggle('album-selecting', albumGridSelecting);
  albumMediaPanel?.classList.toggle('selecting', albumMediaSelecting);
}

async function removeMediaFromAlbums(photoIds) {
  if (!photoIds?.length) return;
  const tasks = [];
  for (const [albumId, set] of albumMembership.entries()) {
    let changed = false;
    for (const pid of photoIds) {
      if (set.has(pid)) {
        set.delete(pid);
        changed = true;
        tasks.push(idbDelete(db, COLLECTION_ITEMS_STORE, `${albumId}-${pid}`));
      }
    }
    if (changed && set.size === 0 && currentAlbumId === albumId && activeTab === TAB_ALBUMS) {
      albumMediaEmptyEl?.classList.remove('hidden');
    }
  }
  if (tasks.length) await Promise.allSettled(tasks);
}

function onViewerPointerDown(e) {
  if (e.pointerType === 'mouse' && e.button !== 0) return;
  viewerMediaEl.setPointerCapture(e.pointerId);
  gesture.active = true;
  gesture.pointerId = e.pointerId;
  gesture.startX = e.clientX;
  gesture.startY = e.clientY;
  gesture.initialX = e.clientX;
  gesture.initialY = e.clientY;
  gesture.startTime = performance.now();
  gesture.panMode = isZoomed;
}

function onViewerPointerMove(e) {
  if (!gesture.active || gesture.pointerId !== e.pointerId) return;
  if (gesture.panMode && isZoomed) {
    const dx = e.clientX - gesture.startX;
    const dy = e.clientY - gesture.startY;
    panX += dx;
    panY += dy;
    gesture.startX = e.clientX;
    gesture.startY = e.clientY;
    applyZoomTransform();
  }
}

function onViewerPointerUp(e) {
  if (!gesture.active || gesture.pointerId !== e.pointerId) return;
  viewerMediaEl.releasePointerCapture(e.pointerId);
  const totalDx = e.clientX - gesture.initialX;
  const totalDy = e.clientY - gesture.initialY;
  const duration = performance.now() - gesture.startTime;
  if (!gesture.panMode) {
    if (Math.abs(totalDx) > 60 && Math.abs(totalDy) < 120 && duration < 600) {
      navigateViewer(totalDx > 0 ? -1 : 1);
    } else if (Math.abs(totalDx) < 10 && Math.abs(totalDy) < 10) {
      handleTap(e);
    }
  } else if (Math.abs(totalDx) < 10 && Math.abs(totalDy) < 10) {
    handleTap(e);
  }
  resetGesture();
}

function resetGesture() {
  gesture.active = false;
  gesture.pointerId = null;
}

async function handleMoveToFolder() {
  const current = getCurrentItem();
  if (!current) return alert('Open a photo or video first.');
  const targetFolder = await pickFolderDestination({ title: 'Move to folder', exclude: [currentFolder] });
  if (targetFolder === undefined) return;
  if ((current.folderId ?? null) === targetFolder) {
    alert('Already in that folder.');
    return;
  }
  idbPut(db, STORE, { ...current, folderId: targetFolder }).then(async () => {
    await refreshGallery();
    await loadFolders();
    closeViewer();
    alert('Moved to ' + (targetFolder ? folderTitleFor(targetFolder) : 'Main Library') + '.');
  });
}

async function handleAddToAlbum() {
  const current = getCurrentItem();
  if (!current) return alert('Open a photo or video first.');
  let selected = currentAlbumId;
  if (!selected) {
    const choice = await pickAlbumDestination();
    if (choice == null) return;
    selected = Number(choice);
  }
  const membership = albumMembership.get(selected) || new Set();
  if (membership.has(current.id)) {
    alert('Already in that album.');
    return;
  }
  const entry = { id: `${selected}-${current.id}`, albumId: selected, photoId: current.id, created: Date.now() };
  idbAdd(db, COLLECTION_ITEMS_STORE, entry).then(async () => {
    if (!albumMembership.has(selected)) albumMembership.set(selected, new Set());
    albumMembership.get(selected).add(current.id);
    renderAlbumGrid();
    if (currentAlbumId === selected) updateHeader();
    if (activeTab === TAB_ALBUMS && currentAlbumId === selected) renderGallery();
    alert('Added to album.');
  }).catch(() => alert('Unable to add to album.'));
}

function handleSaveMedia() {
  const current = getCurrentItem();
  if (!current) return alert('Open a photo or video first.');
  const url = URL.createObjectURL(current.blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = current.name || 'media';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

async function handleInfo() {
  const current = getCurrentItem();
  if (!current) return alert('Open a photo or video first.');
  const result = await openInfoModal(current);
  if (!result || !result.name) return;
  const newName = result.name.trim();
  const safeName = cleanFileName(newName, current.name || 'media');
  if (!safeName || safeName === current.name) return;
  current.name = safeName;
  if (viewerTitle) viewerTitle.textContent = safeName;
  await idbPut(db, STORE, { ...current, name: safeName });
  const cacheIndex = photoCache.findIndex(item => item.id === current.id);
  if (cacheIndex > -1) {
    photoCache[cacheIndex] = { ...photoCache[cacheIndex], name: safeName };
  }
  renderGallery();
}

document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    if (!modal.classList.contains('hidden')) closeModal();
    if (!photoViewer.classList.contains('hidden')) closeViewer();
    if (!inputModal.classList.contains('hidden')) closeInputModal(null);
    if (!textFileModal.classList.contains('hidden')) closeTextFileModal(null);
    if (listPickerModal && !listPickerModal.classList.contains('hidden')) closeListPicker(undefined);
    if (infoModal && !infoModal.classList.contains('hidden')) closeInfoModal(null);
  }
  if (!photoViewer.classList.contains('hidden')) {
    if (e.key === 'ArrowRight') { e.preventDefault(); navigateViewer(1); }
    if (e.key === 'ArrowLeft') { e.preventDefault(); navigateViewer(-1); }
  }
});

clearBtn?.addEventListener('click', async () => {
  if (confirm('Remove all media from this device?')) {
    await idbClear(db, STORE);
    await refreshGallery();
  }
});

exportBtn?.addEventListener('click', exportZip);

async function exportZip() {
  await DB_READY;
  const files = await idbAll(db, STORE);
  if (!files.length) return alert('No media to export.');
  const encoder = new TextEncoder();
  const fileRecords = [];
  let offset = 0;
  const chunks = [];

  function crc32(buf) {
    const table = (function(){
      let c, table = new Uint32Array(256);
      for (let n=0; n<256; n++) { c=n; for (let k=0;k<8;k++) c = (c&1)?(0xEDB88320^(c>>>1)):(c>>>1); table[n]=c>>>0; }
      return table;
    })();
    let crc = 0 ^ (-1);
    for (let i=0; i<buf.length; i++) crc = (crc>>>8) ^ table[(crc ^ buf[i]) & 0xFF];
    return (crc ^ (-1)) >>> 0;
  }

  for (const f of files) {
    const name = (f.name || 'media').replace(/\//g, '_');
    const nameBytes = encoder.encode(name);
    const data = new Uint8Array(await f.blob.arrayBuffer());
    const c = crc32(data);

    const local = new DataView(new ArrayBuffer(30));
    let p=0;
    local.setUint32(p, 0x04034b50, true); p+=4;
    local.setUint16(p, 20, true); p+=2;
    local.setUint16(p, 0, true); p+=2;
    local.setUint16(p, 0, true); p+=2;
    local.setUint16(p, 0, true); p+=2;
    local.setUint16(p, 0, true); p+=2;
    local.setUint32(p, c, true); p+=4;
    local.setUint32(p, data.length, true); p+=4;
    local.setUint32(p, data.length, true); p+=4;
    local.setUint16(p, nameBytes.length, true); p+=2;
    local.setUint16(p, 0, true); p+=2;

    chunks.push(new Uint8Array(local.buffer));
    chunks.push(nameBytes);
    chunks.push(data);

    fileRecords.push({ nameBytes, c, size: data.length, offset });
    offset += 30 + nameBytes.length + data.length;
  }

  const cdChunks = [];
  let cdSize = 0;
  for (const rec of fileRecords) {
    const cd = new DataView(new ArrayBuffer(46));
    let p=0;
    cd.setUint32(p, 0x02014b50, true); p+=4;
    cd.setUint16(p, 20, true); p+=2;
    cd.setUint16(p, 20, true); p+=2;
    cd.setUint16(p, 0, true); p+=2;
    cd.setUint16(p, 0, true); p+=2;
    cd.setUint16(p, 0, true); p+=2;
    cd.setUint16(p, 0, true); p+=2;
    cd.setUint32(p, rec.c, true); p+=4;
    cd.setUint32(p, rec.size, true); p+=4;
    cd.setUint32(p, rec.size, true); p+=4;
    cd.setUint16(p, rec.nameBytes.length, true); p+=2;
    cd.setUint16(p, 0, true); p+=2;
    cd.setUint16(p, 0, true); p+=2;
    cd.setUint16(p, 0, true); p+=2;
    cd.setUint16(p, 0, true); p+=2;
    cd.setUint32(p, 0, true); p+=4;
    cd.setUint32(p, rec.offset, true); p+=4;

    cdChunks.push(new Uint8Array(cd.buffer));
    cdChunks.push(rec.nameBytes);
    cdSize += 46 + rec.nameBytes.length;
  }

  const end = new DataView(new ArrayBuffer(22));
  let q=0;
  end.setUint32(q, 0x06054b50, true); q+=4;
  end.setUint16(q, 0, true); q+=2;
  end.setUint16(q, 0, true); q+=2;
  end.setUint16(q, fileRecords.length, true); q+=2;
  end.setUint16(q, fileRecords.length, true); q+=2;
  end.setUint32(q, cdSize, true); q+=4;
  end.setUint32(q, offset, true); q+=4;
  end.setUint16(q, 0, true); q+=2;

  const blob = new Blob([...chunks, ...cdChunks, new Uint8Array(end.buffer)], { type: 'application/zip' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'media.zip';
  a.click();
  URL.revokeObjectURL(url);
}
</script>
</body>
</html>
